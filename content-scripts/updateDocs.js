const fs = require("fs-extra");

const { Octokit } = require("@octokit/core");
const { paginateRest } = require("@octokit/plugin-paginate-rest");
const hash = require("object-hash");

const insecureRandomString = len =>
  Math.random()
    .toString(36)
    .replace(/[^a-z0-9]+/g, "")
    .substr(0, len);

const secrets = {
  githubAccessToken: process.env.GITHUB_ACCESS_TOKEN
};

const getConfig = () => ({
  auth: secrets.githubAccessToken,
  upstream: {
    owner: "splitgraph",
    repo: "splitgraph"
  },
  docs: {
    // Update the docs at this repo
    owner: "splitgraph",
    repo: "splitgraph.com",

    // Push updates to this new branch
    newBranch: `splitbot/update-docs-${insecureRandomString(8)}`,

    // Submit a pull request against this branch
    targetBranch: "next",

    // Use these paths in the repo to find autogenerated docs/manifest
    path: {
      // manifest: "content/docs-manifest.json",
      manifest: "/src/js/splitgraph.com/content/docs-manifest.json",
      sgrCliDocs: {
        latest: "content/docs/9000_sgr",
        archive: "content/docs/9000_sgr/9000_versions"
      },
      pythonApiDocs: {
        latest: "content/docs/9500_python_api",
        archive: "content/docs/9500_python_api/9000_versions"
      }
    }
  },
  assetIsDocs: asset => {
    const { name } = asset;

    return name.includes("docs");
  }
});

const main = async () => {
  const config = getConfig();
  const client = makeClient({ config });

  const manifest = await getCurrentManifest({ config });
  const releases = await fetchReleases({ client, config });

  const {
    latest,
    unchanged,
    created,
    deleted,
    modified
  } = await compareReleases({
    manifest,
    releases,
    client,
    config
  });

  console.log(
    JSON.stringify({ latest, unchanged, created, deleted, modified }, null, 2)
  );

  await applyManifest({
    config,
    manifest,
    latest,
    unchanged,
    created,
    deleted,
    modified
  });

  process.exit(0);

  const { repoPath } = await cloneRepo();

  // A creation is a release that exists in the upstream list of releases but not in the manifest
  // Apply it by extracting the upstream release to the appropriate local directory
  await applyCreations({ repoPath, created });

  // A modification is when the manifest and remote both have a release with
  // the same TAG, but at least one other aspect of the release is different
  // Apply it by overwriting the local files with the contents of the remote
  // Note: this should hopefully be rare, or else not happen once a human has
  //       edited the local files
  await applyModifications({ repoPath, modified });

  // A deletion is an item that we have in the local manifest but not in the remote
  // Apply it by deleting it locally
  await applyDeletions({ repoPath, deleted });

  // Since we save all versions independent of the copy in "latest" (you
  // can alwys access the latest version at its version number too), we
  // simply overwrite the "latest" contents every time
  await overwriteLatest({ repoPath, latest });
};

const findDocsAsset = ({ config, assets = [] }) => {
  return assets.find(config.assetIsDocs);
};

const normalizeAsset = asset => {
  const {
    id,
    url,
    name,
    label,
    created_at,
    updated_at,
    browser_download_url
  } = asset;

  return { id, url, name, label, created_at, updated_at, browser_download_url };
};

const normalizeAssets = ({ config, assets }) => {
  return assets.filter(config.assetIsDocs).map(normalizeAsset);
};

const normalizeRelease = ({ config, release }) => {
  const {
    id,
    tag_name,
    target_commitish,
    created_at,
    published_at,
    assets
  } = release;
  return {
    id,
    tag_name,
    target_commitish,
    created_at,
    published_at,
    assets: normalizeAssets({ config, assets })
  };
};

const releaseSorter = (r1, r2) =>
  new Date(r2.published_at) - new Date(r1.published_at);

// Remove uannecssary fields, sort by recent first, remove duplicates (!)
const normalizeReleases = ({ config, releases }) => {
  // Sort most recent first
  const sortedReleases = releases.sort(releaseSorter);

  // Pick the first of each tag_name
  const dedupedReleases = [];
  while (sortedReleases.length > 0) {
    const nextRelease = sortedReleases.shift();

    if (!findMatchingTag(dedupedReleases, nextRelease)) {
      dedupedReleases.push(nextRelease);
    }
  }

  const normalizedReleases = dedupedReleases
    .map(release => normalizeRelease({ release, config }))
    .filter(release => release.assets.length > 0);

  return normalizedReleases;
};

const makeClient = ({ config }) => {
  const PaginatedOctokit = Octokit.plugin(paginateRest);
  const client = new PaginatedOctokit({ auth: config.auth });

  return client;
};

const fetchReleases = async ({ client, config }) => {
  const releases = await client.paginate(
    "GET /repos/:owner/:repo/releases",
    {
      owner: config.upstream.owner,
      repo: config.upstream.repo,
      per_page: 1
    },
    (response, done) => {
      return normalizeReleases({ config, releases: response.data });
    }
  );

  return releases;
};

/*
  returns {
    latest: { ...release },
    unchanged: [],
    created: [],
    deleted: [],
    modified: []
  }
*/
const compareReleases = async ({ releases, manifest, client, config }) => {
  const manifestReleases = manifest.releases;

  const unchanged = findUnchanged({
    manifestReleases,
    remoteReleases: releases
  });
  const created = findCreated({ manifestReleases, remoteReleases: releases });
  const modified = findModified({ manifestReleases, remoteReleases: releases });
  const deleted = findDeleted({ manifestReleases, remoteReleases: releases });
  const latest = await findLatest({ client, remoteReleases: releases, config });
  const latestChanged = !releasesAreEqual(manifest.latest, latest);
  const anyChanged =
    created.length > 0 ||
    modified.length > 0 ||
    deleted.length > 0 ||
    latestChanged;

  return {
    latestChanged,
    anyChanged,
    unchanged,
    latest,
    created,
    modified,
    deleted
  };
};

const findLatest = async ({ client, remoteReleases, config }) => {
  const { data } = await client.request(
    "GET /repos/:owner/:repo/releases/latest",
    {
      owner: config.upstream.owner,
      repo: config.upstream.repo
    }
  );

  var latest = remoteReleases.find(release => release.id === data.id);

  // In the case a release is published to github which does not include any
  // docs assets, it would be filtered in normalizeReleases, so latest would be undefined
  // Just take the safe option and use the most recent, in this case
  if (!latest && remoteReleases.length > 0) {
    latest = remoteReleases[0];
  }

  return latest || {};
};

const findMatchingTag = (list, release) =>
  list.find(x => x.tag_name === release.tag_name);

const findConflictingTag = (list, release) =>
  list.find(x => x.tag_name === release.tag_name && !releasesAreEqual);

const findMatchingRelease = (list, release) =>
  list.find(x => releasesAreEqual(x, release));

const findUnchanged = ({ manifestReleases, remoteReleases }) => {
  return manifestReleases.filter(
    release => !!findMatchingRelease(remoteReleases, release)
  );
};

// release exists on remote but not manifest
// but, we don't want to double count modified
const findCreated = ({ manifestReleases, remoteReleases }) => {
  const created = remoteReleases.filter(
    release =>
      !findMatchingRelease(manifestReleases, release) &&
      !findConflictingTag(manifestReleases, release)
  );

  return created;
};

// tag is same, but fingerprint of release is different
const findModified = ({ manifestReleases, remoteReleases }) => {
  return remoteReleases.filter(
    release => !!findConflictingTag(manifestReleases, release)
  );
};

// tag exists in manifest but not in remote
const findDeleted = ({ manifestReleases, remoteReleases }) => {
  return manifestReleases.filter(
    release => !findMatchingTag(remoteReleases, release)
  );
};

const assetComparator = (assetA, assetB) => {};

const fingerprintAsset = asset => hash(asset);
const fingerprintAssets = assets => hash(new Set(assets.map(fingerprintAsset)));

const fingerprintRelease = release => {
  const { id, tag_name, target_commitish, created_at, published_at } = release;

  const assetHash = fingerprintAssets(release.assets);

  return hash({
    id,
    tag_name,
    target_commitish,
    created_at,
    published_at,
    assetHash
  });
};

const releasesAreEqual = (releaseA, releaseB) => {
  const equal = fingerprintRelease(releaseA) === fingerprintRelease(releaseB);
  return equal;
};

const getEmptyManifest = () => {
  return {
    // a tag which matches at least one release (prefer the most recent)
    latest: {},

    // releases, most recent first
    releases: []
  };
};

const getCurrentManifest = async ({ config }) => {
  try {
    return require(config.docs.path.manifest);
  } catch {
    console.warn("Warning: using empty manifest");
    return getEmptyManifest();
  }
};

const applyManifest = async ({
  config,
  manifest,
  latest,
  unchanged,
  created,
  deleted,
  modified
}) => {
  const nextReleases = [...unchanged, ...created]
    .filter(release => !findMatchingRelease(deleted, release))
    .map(release =>
      findConflictingTag(modified, release)
        ? findMatchingTag(modified, release)
        : release
    )
    .sort(releaseSorter);

  const nextManifest = {
    latest,
    releases: nextReleases
  };

  await fs.writeJson(config.docs.path.manifest, nextManifest, { spaces: 2 });

  return nextManifest;
};

const applyCreations = async () => {};

const applyDeletions = async () => {};

const applyModifications = async () => {};

const adjustLatest = async () => {};

const fetchRelevantAssets = async () => {};

const yargs = require("yargs").command(
  "$0",
  `
Download docs from github releases and sync with @splitgraph/content by
overwriting files in directory when necessary.
Then submit a PR to splitgraph/splitgraph.com

- Fetch all releases at github:splitgraph/splitgraph that include docs asset

- For each asset, compare {  } to entry in local docs/manifest.json

- Check the remote /latest release against local /latst release

  `,
  yargs => {
    yargs;
  }
);

const { argv } = yargs;

main()
  .then(() => console.log("Done"))
  .catch(console.trace);
