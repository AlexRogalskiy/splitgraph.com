
import "@splitgraph/design/css/sphinxtheme.css";

export const meta = {
  title: "splitgraph.core package",
  id: "splitgraph.core package"
};

<div className=" rst-content"><nav className="toc"><ol className="toc-level toc-level-1"><li className="toc-item toc-item-h2"><a className="toc-link toc-link-h2" href="#module-contents">Module contents</a></li><li className="toc-item toc-item-h2"><a className="toc-link toc-link-h2" href="#subpackages">Subpackages</a></li><li className="toc-item toc-item-h2"><a className="toc-link toc-link-h2" href="#submodules">Submodules</a><ol className="toc-level toc-level-2"><li className="toc-item toc-item-h2"><a className="toc-link toc-link-h2" href="#splitgraphcorecommon-module">splitgraph.core.common module</a></li><li className="toc-item toc-item-h2"><a className="toc-link toc-link-h2" href="#splitgraphcoreengine-module">splitgraph.core.engine module</a></li><li className="toc-item toc-item-h2"><a className="toc-link toc-link-h2" href="#splitgraphcorefdw_checkout-module">splitgraph.core.fdw_checkout module</a></li><li className="toc-item toc-item-h2"><a className="toc-link toc-link-h2" href="#splitgraphcorefragment_manager-module">splitgraph.core.fragment_manager module</a></li><li className="toc-item toc-item-h2"><a className="toc-link toc-link-h2" href="#splitgraphcoreimage-module">splitgraph.core.image module</a></li><li className="toc-item toc-item-h2"><a className="toc-link toc-link-h2" href="#splitgraphcoreimage_manager-module">splitgraph.core.image_manager module</a></li><li className="toc-item toc-item-h2"><a className="toc-link toc-link-h2" href="#splitgraphcoremetadata_manager-module">splitgraph.core.metadata_manager module</a></li><li className="toc-item toc-item-h2"><a className="toc-link toc-link-h2" href="#splitgraphcoreobject_manager-module">splitgraph.core.object_manager module</a></li><li className="toc-item toc-item-h2"><a className="toc-link toc-link-h2" href="#splitgraphcoreregistry-module">splitgraph.core.registry module</a></li><li className="toc-item toc-item-h2"><a className="toc-link toc-link-h2" href="#splitgraphcorerepository-module">splitgraph.core.repository module</a></li><li className="toc-item toc-item-h2"><a className="toc-link toc-link-h2" href="#splitgraphcoresql-module">splitgraph.core.sql module</a></li><li className="toc-item toc-item-h2"><a className="toc-link toc-link-h2" href="#splitgraphcoretable-module">splitgraph.core.table module</a></li><li className="toc-item toc-item-h2"><a className="toc-link toc-link-h2" href="#splitgraphcoretypes-module">splitgraph.core.types module</a></li></ol></li></ol></nav><div className="section" id="module-splitgraph.core">
<span id="module-contents"></span><h2 id="module-contents">Module contents<a className="headerlink" href="#module-splitgraph.core" title="Permalink to this headline">¶</a></h2>
<p>Core Splitgraph functionality: versioning and sharing tables.</p>
<p>The main point of interaction with the Splitgraph API is a <a className="reference internal" href="#splitgraph.core.repository.Repository" title="splitgraph.core.repository.Repository"><code className="xref py py-class docutils literal notranslate"><span className="pre">splitgraph.core.repository.Repository</span></code></a> object
representing a local or a remote Splitgraph repository. Repositories can be created using one of the
following methods:</p>
<blockquote>
<div><ul className="simple">
<li><p>Directly by invoking <cite>Repository(namespace, name, engine)</cite> where <cite>engine</cite> is the engine that the repository
belongs to (that can be gotten with <cite>get_engine(engine_name)</cite>. If the created repository doesn’t actually exist
on the engine, it must first be initialized with <cite>repository.init()</cite>.</p></li>
<li><p>By using <a className="reference internal" href="#splitgraph.core.engine.lookup_repository" title="splitgraph.core.engine.lookup_repository"><code className="xref py py-func docutils literal notranslate"><span className="pre">splitgraph.core.engine.lookup_repository()</span></code></a> which will search for the repository on the current
lookup path.</p></li>
</ul>
</div></blockquote>
</div><div className="section" id="splitgraph-core-package">

<div className="section" id="subpackages">
<h2 id="subpackages">Subpackages<a className="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div className="toctree-wrapper compound">
<ul>
<li className="toctree-l1"><a className="reference internal" href="splitgraph.core.indexing/">splitgraph.core.indexing package</a><ul>
<li className="toctree-l2"><a className="reference internal" href="splitgraph.core.indexing/#submodules">Submodules</a></li>
<li className="toctree-l2"><a className="reference internal" href="splitgraph.core.indexing/#module-splitgraph.core.indexing.bloom">splitgraph.core.indexing.bloom module</a></li>
<li className="toctree-l2"><a className="reference internal" href="splitgraph.core.indexing/#module-splitgraph.core.indexing.range">splitgraph.core.indexing.range module</a></li>
<li className="toctree-l2"><a className="reference internal" href="splitgraph.core.indexing/#module-splitgraph.core.indexing">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div className="section" id="submodules">
<h2 id="submodules">Submodules<a className="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div className="section" id="module-splitgraph.core.common">
<span id="splitgraph-core-common-module"></span><h2 id="splitgraphcorecommon-module">splitgraph.core.common module<a className="headerlink" href="#module-splitgraph.core.common" title="Permalink to this headline">¶</a></h2>
<p>Common internal functions used by Splitgraph commands.</p>
<dl className="class">
<dt id="splitgraph.core.common.CallbackList">
<em className="property">class </em><code className="sig-prename descclassname">splitgraph.core.common.</code><code className="sig-name descname">CallbackList</code><a className="headerlink" href="#splitgraph.core.common.CallbackList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code className="xref py py-class docutils literal notranslate"><span className="pre">list</span></code></p>
<p>Used to pass around and call multiple callbacks at once.</p>
</dd></dl>

<dl className="class">
<dt id="splitgraph.core.common.Tracer">
<em className="property">class </em><code className="sig-prename descclassname">splitgraph.core.common.</code><code className="sig-name descname">Tracer</code><a className="headerlink" href="#splitgraph.core.common.Tracer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code className="xref py py-class docutils literal notranslate"><span className="pre">object</span></code></p>
<p>Accumulates events and returns the times between them.</p>
<dl className="method">
<dt id="splitgraph.core.common.Tracer.get_durations">
<code className="sig-name descname">get_durations</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → List[Tuple[str, float]]<a className="headerlink" href="#splitgraph.core.common.Tracer.get_durations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all events and durations between them.
:return: List of (event name, time to this event from the previous event (or start))</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.common.Tracer.get_total_time">
<code className="sig-name descname">get_total_time</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → float<a className="headerlink" href="#splitgraph.core.common.Tracer.get_total_time" title="Permalink to this definition">¶</a></dt>
<dd><dl className="field-list simple">
<dt className="field-odd">Returns</dt>
<dd className="field-odd"><p>Time from start to the final logged event.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.common.Tracer.log">
<code className="sig-name descname">log</code><span className="sig-paren">(</span><em className="sig-param">event: str</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.common.Tracer.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Log an event at the current time
:param event: Event name</p>
</dd></dl>

</dd></dl>

<dl className="function">
<dt id="splitgraph.core.common.adapt">
<code className="sig-prename descclassname">splitgraph.core.common.</code><code className="sig-name descname">adapt</code><span className="sig-paren">(</span><em className="sig-param">value: Any</em>, <em className="sig-param">pg_type: str</em><span className="sig-paren">)</span> → Any<a className="headerlink" href="#splitgraph.core.common.adapt" title="Permalink to this definition">¶</a></dt>
<dd><p>Coerces a value with a PG type into its Python equivalent.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>value</strong> – Value</p></li>
<li><p><strong>pg_type</strong> – Postgres datatype</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>Coerced value.</p>
</dd>
</dl>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.common.aggregate_changes">
<code className="sig-prename descclassname">splitgraph.core.common.</code><code className="sig-name descname">aggregate_changes</code><span className="sig-paren">(</span><em className="sig-param">query_result: List[Tuple[int, int]], initial: Optional[Tuple[int, int, int]] = None</em><span className="sig-paren">)</span> → Tuple[int, int, int]<a className="headerlink" href="#splitgraph.core.common.aggregate_changes" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a changeset to the aggregated diff result</p>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.common.coerce_val_to_json">
<code className="sig-prename descclassname">splitgraph.core.common.</code><code className="sig-name descname">coerce_val_to_json</code><span className="sig-paren">(</span><em className="sig-param">val: Any</em><span className="sig-paren">)</span> → Any<a className="headerlink" href="#splitgraph.core.common.coerce_val_to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a Python value to a string/float that can be stored as JSON.</p>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.common.ensure_metadata_schema">
<code className="sig-prename descclassname">splitgraph.core.common.</code><code className="sig-name descname">ensure_metadata_schema</code><span className="sig-paren">(</span><em className="sig-param">engine: PsycopgEngine</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.common.ensure_metadata_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the metadata schema if it doesn’t exist</p>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.common.gather_sync_metadata">
<code className="sig-prename descclassname">splitgraph.core.common.</code><code className="sig-name descname">gather_sync_metadata</code><span className="sig-paren">(</span><em className="sig-param">target: Repository</em>, <em className="sig-param">source: Repository</em><span className="sig-paren">)</span> → Any<a className="headerlink" href="#splitgraph.core.common.gather_sync_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Inspects two Splitgraph repositories and gathers metadata that is required to bring target up to
date with source.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>target</strong> – Target Repository object</p></li>
<li><p><strong>source</strong> – Source repository object</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.common.get_metadata_schema_version">
<code className="sig-prename descclassname">splitgraph.core.common.</code><code className="sig-name descname">get_metadata_schema_version</code><span className="sig-paren">(</span><em className="sig-param">engine: PsycopgEngine</em><span className="sig-paren">)</span> → Tuple[str, datetime.datetime]<a className="headerlink" href="#splitgraph.core.common.get_metadata_schema_version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl className="function">
<dt id="splitgraph.core.common.insert">
<code className="sig-prename descclassname">splitgraph.core.common.</code><code className="sig-name descname">insert</code><span className="sig-paren">(</span><em className="sig-param">table: str, columns: Sequence[str], schema: str = 'splitgraph_meta'</em><span className="sig-paren">)</span> → psycopg2.sql.Composed<a className="headerlink" href="#splitgraph.core.common.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>A generic SQL SELECT constructor to simplify metadata access queries so that we don’t have to repeat the same
identifiers everywhere.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>table</strong> – Table to select from.</p></li>
<li><p><strong>columns</strong> – Columns to insert as a list of strings.</p></li>
<li><p><strong>schema</strong> – Schema that contains the table</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>A psycopg2.sql.SQL object with the query (parameterized)</p>
</dd>
</dl>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.common.manage_audit">
<code className="sig-prename descclassname">splitgraph.core.common.</code><code className="sig-name descname">manage_audit</code><span className="sig-paren">(</span><em className="sig-param">func: Callable</em><span className="sig-paren">)</span> → Callable<a className="headerlink" href="#splitgraph.core.common.manage_audit" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator to be put around various Splitgraph commands that performs general admin and auditing management
(makes sure the metadata schema exists and delete/add required audit triggers)</p>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.common.manage_audit_triggers">
<code className="sig-prename descclassname">splitgraph.core.common.</code><code className="sig-name descname">manage_audit_triggers</code><span className="sig-paren">(</span><em className="sig-param">engine: PostgresEngine</em>, <em className="sig-param">object_engine: Optional[PostgresEngine] = None</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.common.manage_audit_triggers" title="Permalink to this definition">¶</a></dt>
<dd><p>Does bookkeeping on audit triggers / audit table:</p>
<blockquote>
<div><ul className="simple">
<li><p>Detect tables that are being audited that don’t need to be any more
(e.g. they’ve been unmounted)</p></li>
<li><p>Drop audit triggers for those and delete all audit info for them</p></li>
<li><p>Set up audit triggers for new tables</p></li>
</ul>
</div></blockquote>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>engine</strong> – Metadata engine with information about images and their checkout state</p></li>
<li><p><strong>object_engine</strong> – Object engine where the checked-out table and the audit triggers are located.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.common.prepare_publish_data">
<code className="sig-prename descclassname">splitgraph.core.common.</code><code className="sig-name descname">prepare_publish_data</code><span className="sig-paren">(</span><em className="sig-param">image: Image</em>, <em className="sig-param">repository: Repository</em>, <em className="sig-param">include_table_previews: bool</em><span className="sig-paren">)</span> → Tuple[Optional[Dict[str, List[Tuple]]], Dict[str, TableSchema]]<a className="headerlink" href="#splitgraph.core.common.prepare_publish_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare previews and schemata for a given image for publishing to a registry.</p>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.common.pretty_size">
<code className="sig-prename descclassname">splitgraph.core.common.</code><code className="sig-name descname">pretty_size</code><span className="sig-paren">(</span><em className="sig-param">size: Union[int, float]</em><span className="sig-paren">)</span> → str<a className="headerlink" href="#splitgraph.core.common.pretty_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a size in bytes to its string representation (e.g. 1024 -> 1KiB)
:param size: Size in bytes</p>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.common.select">
<code className="sig-prename descclassname">splitgraph.core.common.</code><code className="sig-name descname">select</code><span className="sig-paren">(</span><em className="sig-param">table: str</em>, <em className="sig-param">columns: str = '*'</em>, <em className="sig-param">where: str = ''</em>, <em className="sig-param">schema: str = 'splitgraph_meta'</em>, <em className="sig-param">table_args: Optional[str] = None</em><span className="sig-paren">)</span> → psycopg2.sql.Composed<a className="headerlink" href="#splitgraph.core.common.select" title="Permalink to this definition">¶</a></dt>
<dd><p>A generic SQL SELECT constructor to simplify metadata access queries so that we don’t have to repeat the same
identifiers everywhere.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>table</strong> – Table to select from.</p></li>
<li><p><strong>columns</strong> – Columns to select as a string. WARN: concatenated directly without any formatting.</p></li>
<li><p><strong>where</strong> – If specified, added to the query with a “WHERE” keyword. WARN also concatenated directly.</p></li>
<li><p><strong>schema</strong> – Defaults to SPLITGRAPH_META_SCHEMA.</p></li>
<li><p><strong>table_args</strong> – If specified, appends to the FROM clause after the table specification,
for example, SELECT * FROM “splitgraph_api”.”get_images” (%s, %s) …</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>A psycopg2.sql.SQL object with the query.</p>
</dd>
</dl>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.common.set_head">
<code className="sig-prename descclassname">splitgraph.core.common.</code><code className="sig-name descname">set_head</code><span className="sig-paren">(</span><em className="sig-param">repository: Repository, image: Optional[str]</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.common.set_head" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the HEAD pointer of a given repository to a given image. Shouldn’t be used directly.</p>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.common.set_tag">
<code className="sig-prename descclassname">splitgraph.core.common.</code><code className="sig-name descname">set_tag</code><span className="sig-paren">(</span><em className="sig-param">repository: Repository, image_hash: Optional[str], tag: str</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.common.set_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal function – add a tag to an image.</p>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.common.slow_diff">
<code className="sig-prename descclassname">splitgraph.core.common.</code><code className="sig-name descname">slow_diff</code><span className="sig-paren">(</span><em className="sig-param">repository: Repository, table_name: str, image_1: Optional[str], image_2: Optional[str], aggregate: bool</em><span className="sig-paren">)</span> → Union[Tuple[int, int, int], List[Tuple[bool, Tuple]]]<a className="headerlink" href="#splitgraph.core.common.slow_diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Materialize both tables and manually diff them</p>
</dd></dl>

</div>
<div className="section" id="module-splitgraph.core.engine">
<span id="splitgraph-core-engine-module"></span><h2 id="splitgraphcoreengine-module">splitgraph.core.engine module<a className="headerlink" href="#module-splitgraph.core.engine" title="Permalink to this headline">¶</a></h2>
<p>Routines for managing Splitgraph engines, including looking up repositories and managing objects.</p>
<dl className="function">
<dt id="splitgraph.core.engine.get_current_repositories">
<code className="sig-prename descclassname">splitgraph.core.engine.</code><code className="sig-name descname">get_current_repositories</code><span className="sig-paren">(</span><em className="sig-param">engine: PostgresEngine</em><span className="sig-paren">)</span> → List[Tuple[Repository, Optional[Image]]]<a className="headerlink" href="#splitgraph.core.engine.get_current_repositories" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists all repositories currently in the engine.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>engine</strong> – Engine</p>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>List of (Repository object, current HEAD image)</p>
</dd>
</dl>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.engine.init_engine">
<code className="sig-prename descclassname">splitgraph.core.engine.</code><code className="sig-name descname">init_engine</code><span className="sig-paren">(</span><em className="sig-param">skip_object_handling: bool = False</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.engine.init_engine" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the engine by:</p>
<blockquote>
<div><ul className="simple">
<li><p>performing any required engine-custom initialization</p></li>
<li><p>creating the metadata tables</p></li>
</ul>
</div></blockquote>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>skip_object_handling</strong> – If True, skips installing routines related to
object handling and checkouts (like audit triggers and CStore management).</p>
</dd>
</dl>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.engine.lookup_repository">
<code className="sig-prename descclassname">splitgraph.core.engine.</code><code className="sig-name descname">lookup_repository</code><span className="sig-paren">(</span><em className="sig-param">name: str</em>, <em className="sig-param">include_local: bool = False</em><span className="sig-paren">)</span> → Repository<a className="headerlink" href="#splitgraph.core.engine.lookup_repository" title="Permalink to this definition">¶</a></dt>
<dd><p>Queries the SG engines on the lookup path to locate one hosting the given repository.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>name</strong> – Repository name</p></li>
<li><p><strong>include_local</strong> – If True, also queries the local engine</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>Local or remote Repository object</p>
</dd>
</dl>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.engine.repository_exists">
<code className="sig-prename descclassname">splitgraph.core.engine.</code><code className="sig-name descname">repository_exists</code><span className="sig-paren">(</span><em className="sig-param">repository: Repository</em><span className="sig-paren">)</span> → bool<a className="headerlink" href="#splitgraph.core.engine.repository_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if a repository exists on the engine.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>repository</strong> – Repository object</p>
</dd>
</dl>
</dd></dl>

</div>
<div className="section" id="splitgraph-core-fdw-checkout-module">
<h2 id="splitgraphcorefdw_checkout-module">splitgraph.core.fdw_checkout module<a className="headerlink" href="#splitgraph-core-fdw-checkout-module" title="Permalink to this headline">¶</a></h2>
</div>
<div className="section" id="module-splitgraph.core.fragment_manager">
<span id="splitgraph-core-fragment-manager-module"></span><h2 id="splitgraphcorefragment_manager-module">splitgraph.core.fragment_manager module<a className="headerlink" href="#module-splitgraph.core.fragment_manager" title="Permalink to this headline">¶</a></h2>
<p>Routines related to storing tables as fragments.</p>
<dl className="class">
<dt id="splitgraph.core.fragment_manager.Digest">
<em className="property">class </em><code className="sig-prename descclassname">splitgraph.core.fragment_manager.</code><code className="sig-name descname">Digest</code><span className="sig-paren">(</span><em className="sig-param">shorts: Tuple[int, ...]</em><span className="sig-paren">)</span><a className="headerlink" href="#splitgraph.core.fragment_manager.Digest" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code className="xref py py-class docutils literal notranslate"><span className="pre">object</span></code></p>
<p>Homomorphic hashing similar to LtHash (but limited to being backed by 256-bit hashes). The main property is that
for any rows A, B, LtHash(A) + LtHash(B) = LtHash(A+B). This is done by construction: we simply hash individual
rows and then do bit-wise addition / subtraction of individual hashes to come up with the full table hash.</p>
<p>Hence, the content hash of any Splitgraph table fragment is the sum of hashes of its added rows minus the sum
of hashes of its deleted rows (including the old values of the rows that have been updated). This has a very
useful implication: the hash of a full Splitgraph table is equal to the sum of hashes of its individual fragments.</p>
<p>This property can be used to simplify deduplication.</p>
<dl className="method">
<dt id="splitgraph.core.fragment_manager.Digest.empty">
<em className="property">classmethod </em><code className="sig-name descname">empty</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → splitgraph.core.fragment_manager.Digest<a className="headerlink" href="#splitgraph.core.fragment_manager.Digest.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an empty Digest instance such that for any Digest D, D + empty == D - empty == D</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.fragment_manager.Digest.from_hex">
<em className="property">classmethod </em><code className="sig-name descname">from_hex</code><span className="sig-paren">(</span><em className="sig-param">hex_string: str</em><span className="sig-paren">)</span> → splitgraph.core.fragment_manager.Digest<a className="headerlink" href="#splitgraph.core.fragment_manager.Digest.from_hex" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Digest from a 64-characters (256-bit) hexadecimal string</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.fragment_manager.Digest.from_memoryview">
<em className="property">classmethod </em><code className="sig-name descname">from_memoryview</code><span className="sig-paren">(</span><em className="sig-param">memory: Union[bytes, memoryview]</em><span className="sig-paren">)</span> → splitgraph.core.fragment_manager.Digest<a className="headerlink" href="#splitgraph.core.fragment_manager.Digest.from_memoryview" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Digest from a 256-bit memoryview/bytearray.</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.fragment_manager.Digest.hex">
<code className="sig-name descname">hex</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → str<a className="headerlink" href="#splitgraph.core.fragment_manager.Digest.hex" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the hash into a hexadecimal value.</p>
</dd></dl>

</dd></dl>

<dl className="class">
<dt id="splitgraph.core.fragment_manager.FragmentManager">
<em className="property">class </em><code className="sig-prename descclassname">splitgraph.core.fragment_manager.</code><code className="sig-name descname">FragmentManager</code><span className="sig-paren">(</span><em className="sig-param">object_engine: PostgresEngine</em>, <em className="sig-param">metadata_engine: Optional[PostgresEngine] = None</em><span className="sig-paren">)</span><a className="headerlink" href="#splitgraph.core.fragment_manager.FragmentManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a className="reference internal" href="#splitgraph.core.metadata_manager.MetadataManager" title="splitgraph.core.metadata_manager.MetadataManager"><code className="xref py py-class docutils literal notranslate"><span className="pre">splitgraph.core.metadata_manager.MetadataManager</span></code></a></p>
<p>A storage engine for Splitgraph tables. Each table can be stored as one or more immutable fragments that can
optionally overwrite each other. When a new table is created, it’s split up into multiple base fragments. When
a new version of the table is written, the audit log is inspected and one or more patch fragments are created,
to be based on the fragments the previous version of the table consisted of. Only the top fragments in this stack
are stored in the table metadata: to reconstruct the whole table, the links from the top fragments down to the
base fragments have to be followed.</p>
<p>In addition, the fragments engine also supports min-max indexing on fragments: this is used to only fetch fragments
that are required for a given query.</p>
<dl className="method">
<dt id="splitgraph.core.fragment_manager.FragmentManager.calculate_content_hash">
<code className="sig-name descname">calculate_content_hash</code><span className="sig-paren">(</span><em className="sig-param">schema: str</em>, <em className="sig-param">table: str</em><span className="sig-paren">)</span> → str<a className="headerlink" href="#splitgraph.core.fragment_manager.FragmentManager.calculate_content_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the homomorphic hash of table contents.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>schema</strong> – Schema the table belongs to</p></li>
<li><p><strong>table</strong> – Name of the table</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>A 64-character (256-bit) hexadecimal string with the content hash of the table.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.fragment_manager.FragmentManager.calculate_fragment_insertion_hash">
<code className="sig-name descname">calculate_fragment_insertion_hash</code><span className="sig-paren">(</span><em className="sig-param">schema: str</em>, <em className="sig-param">table: str</em><span className="sig-paren">)</span> → splitgraph.core.fragment_manager.Digest<a className="headerlink" href="#splitgraph.core.fragment_manager.FragmentManager.calculate_fragment_insertion_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the homomorphic hash of just the rows that a given fragment inserts
:param schema: Schema the fragment is stored in.
:param table: Name of the table the fragment is stored in.
:return: A <cite>Digest</cite> object</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.fragment_manager.FragmentManager.create_base_fragment">
<code className="sig-name descname">create_base_fragment</code><span className="sig-paren">(</span><em className="sig-param">source_schema: str</em>, <em className="sig-param">source_table: str</em>, <em className="sig-param">namespace: str</em>, <em className="sig-param">limit: Optional[int] = None</em>, <em className="sig-param">after_pk: Optional[Tuple[Any]] = None</em>, <em className="sig-param">extra_indexes: Optional[Dict[str</em>, <em className="sig-param">Dict[str</em>, <em className="sig-param">Dict[str</em>, <em className="sig-param">Any]]]] = None</em><span className="sig-paren">)</span> → str<a className="headerlink" href="#splitgraph.core.fragment_manager.FragmentManager.create_base_fragment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl className="method">
<dt id="splitgraph.core.fragment_manager.FragmentManager.delete_objects">
<code className="sig-name descname">delete_objects</code><span className="sig-paren">(</span><em className="sig-param">objects: Union[Set[str], List[str]]</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.fragment_manager.FragmentManager.delete_objects" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes objects from the Splitgraph cache</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>objects</strong> – A sequence of objects to be deleted</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.fragment_manager.FragmentManager.filter_fragments">
<code className="sig-name descname">filter_fragments</code><span className="sig-paren">(</span><em className="sig-param">object_ids: List[str], table: Table, quals: Any</em><span className="sig-paren">)</span> → List[str]<a className="headerlink" href="#splitgraph.core.fragment_manager.FragmentManager.filter_fragments" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs fuzzy filtering on the given object IDs using the index and a set of qualifiers, discarding
objects that definitely do not match the qualifiers.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>object_ids</strong> – List of object IDs to filter.</p></li>
<li><p><strong>table</strong> – A Table object the objects belong to.</p></li>
<li><p><strong>quals</strong> – </p><p>List of qualifiers in conjunctive normal form that will be matched against the index.
Objects that definitely don’t match these qualifiers will be discarded.</p>
<p>A list containing <cite>[[qual_1, qual_2], [qual_3, qual_4]]</cite> will be interpreted as
(qual_1 OR qual_2) AND (qual_3 OR qual_4).</p>
<p>Each qual is a tuple of <cite>(column_name, operator, value)</cite> where
<cite>operator</cite> can be one of <cite>></cite>, <cite>>=</cite>, <cite>&lt;</cite>, <cite>&lt;=</cite>, <cite>=</cite>.</p>
<p>For unknown operators, it will be assumed that all fragments might match that clause.</p>
<p></p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>List of objects that might match the given qualifiers.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.fragment_manager.FragmentManager.get_min_max_pks">
<code className="sig-name descname">get_min_max_pks</code><span className="sig-paren">(</span><em className="sig-param">fragments: List[str], table_pks: List[Tuple[str, str]]</em><span className="sig-paren">)</span> → List[Tuple[Tuple, Tuple]]<a className="headerlink" href="#splitgraph.core.fragment_manager.FragmentManager.get_min_max_pks" title="Permalink to this definition">¶</a></dt>
<dd><p>Get PK ranges for given fragments using the index (without reading the fragments).</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>fragments</strong> – List of object IDs (must be registered and with the same schema)</p></li>
<li><p><strong>table_pks</strong> – List of tuples (column, type) that form the object PK.</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>List of (min, max) PK for every fragment where PK is a tuple.
If a fragment doesn’t exist or doesn’t have a corresponding index entry,
a SplitGraphError is raised.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.fragment_manager.FragmentManager.record_table_as_base">
<code className="sig-name descname">record_table_as_base</code><span className="sig-paren">(</span><em className="sig-param">repository: Repository</em>, <em className="sig-param">table_name: str</em>, <em className="sig-param">image_hash: str</em>, <em className="sig-param">chunk_size: Optional[int] = 10000</em>, <em className="sig-param">source_schema: Optional[str] = None</em>, <em className="sig-param">source_table: Optional[str] = None</em>, <em className="sig-param">extra_indexes: Optional[Dict[str</em>, <em className="sig-param">Dict[str</em>, <em className="sig-param">Dict[str</em>, <em className="sig-param">Any]]]] = None</em><span className="sig-paren">)</span> → List[str]<a className="headerlink" href="#splitgraph.core.fragment_manager.FragmentManager.record_table_as_base" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the full table verbatim into one or more new base fragments and registers them.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>repository</strong> – Repository</p></li>
<li><p><strong>table_name</strong> – Table name</p></li>
<li><p><strong>image_hash</strong> – Hash of the new image</p></li>
<li><p><strong>chunk_size</strong> – If specified, splits the table into multiple objects with a given number of rows</p></li>
<li><p><strong>source_schema</strong> – Override the schema the source table is stored in</p></li>
<li><p><strong>source_table</strong> – Override the name of the table the source is stored in</p></li>
<li><p><strong>extra_indexes</strong> – Dictionary of &#38;lbrace;index_type: column: index_specific_kwargs&#38;rbrace;.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.fragment_manager.FragmentManager.record_table_as_patch">
<code className="sig-name descname">record_table_as_patch</code><span className="sig-paren">(</span><em className="sig-param">old_table: Table</em>, <em className="sig-param">schema: str</em>, <em className="sig-param">image_hash: str</em>, <em className="sig-param">new_schema_spec: List[splitgraph.core.types.TableColumn] = None</em>, <em className="sig-param">split_changeset: bool = False</em>, <em className="sig-param">extra_indexes: Optional[Dict[str</em>, <em className="sig-param">Dict[str</em>, <em className="sig-param">Dict[str</em>, <em className="sig-param">Any]]]] = None</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.fragment_manager.FragmentManager.record_table_as_patch" title="Permalink to this definition">¶</a></dt>
<dd><p>Flushes the pending changes from the audit table for a given table and records them,
registering the new objects.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>old_table</strong> – Table object pointing to the current HEAD table</p></li>
<li><p><strong>schema</strong> – Schema the table is checked out into.</p></li>
<li><p><strong>image_hash</strong> – Image hash to store the table under</p></li>
<li><p><strong>new_schema_spec</strong> – New schema of the table (use the old table’s schema by default).</p></li>
<li><p><strong>split_changeset</strong> – See <cite>Repository.commit</cite> for reference</p></li>
<li><p><strong>extra_indexes</strong> – Dictionary of &#38;lbrace;index_type: column: index_specific_kwargs&#38;rbrace;.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl className="function">
<dt id="splitgraph.core.fragment_manager.get_chunk_groups">
<code className="sig-prename descclassname">splitgraph.core.fragment_manager.</code><code className="sig-name descname">get_chunk_groups</code><span className="sig-paren">(</span><em className="sig-param">chunks: List[Tuple[str, Any, Any]]</em><span className="sig-paren">)</span> → List[List[Tuple[str, Any, Any]]]<a className="headerlink" href="#splitgraph.core.fragment_manager.get_chunk_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of chunks and their boundaries and combines them
into independent groups such that chunks from no two groups
overlap with each other (intervals are assumed to be closed,
e.g. chunk (1,2) overlaps with chunk (2,3)).</p>
<p>The original order of chunks is preserved within each group.</p>
<p>For example, 4 chunks A, B, C, D that don’t overlap each other
will be grouped into 4 groups <cite>[A], [B], [C], [D]</cite>.</p>
<p>If A overlaps B, the result will be [A, B], [C], [D].</p>
<p>If in addition B overlaps C (but not A), the result will be <cite>[A, B, C], [D]</cite>.</p>
<p>If in addition D overlaps any of A, B or C, the result will be <cite>[A, B, C, D]</cite>
(despite that D is located before A: it will be last since it was last in the
original list).</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>chunks</strong> – List of (chunk_id, start, end)</p>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>List of lists of (chunk_id, start, end)</p>
</dd>
</dl>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.fragment_manager.get_temporary_table_id">
<code className="sig-prename descclassname">splitgraph.core.fragment_manager.</code><code className="sig-name descname">get_temporary_table_id</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → str<a className="headerlink" href="#splitgraph.core.fragment_manager.get_temporary_table_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a random ID for temporary/staging objects that haven’t had their ID calculated yet.</p>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.fragment_manager.getrandbits">
<code className="sig-prename descclassname">splitgraph.core.fragment_manager.</code><code className="sig-name descname">getrandbits</code><span className="sig-paren">(</span><em className="sig-param">k</em><span className="sig-paren">)</span> → x.  Generates an int with k random bits.<a className="headerlink" href="#splitgraph.core.fragment_manager.getrandbits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div className="section" id="module-splitgraph.core.image">
<span id="splitgraph-core-image-module"></span><h2 id="splitgraphcoreimage-module">splitgraph.core.image module<a className="headerlink" href="#module-splitgraph.core.image" title="Permalink to this headline">¶</a></h2>
<p>Image representation and provenance</p>
<dl className="class">
<dt id="splitgraph.core.image.Image">
<em className="property">class </em><code className="sig-prename descclassname">splitgraph.core.image.</code><code className="sig-name descname">Image</code><a className="headerlink" href="#splitgraph.core.image.Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code className="xref py py-class docutils literal notranslate"><span className="pre">tuple</span></code></p>
<p>Represents a Splitgraph image. Should’t be created directly, use Image-loading methods in the
<a className="reference internal" href="#splitgraph.core.repository.Repository" title="splitgraph.core.repository.Repository"><code className="xref py py-class docutils literal notranslate"><span className="pre">splitgraph.core.repository.Repository</span></code></a> class instead.</p>
<dl className="method">
<dt id="splitgraph.core.image.Image.checkout">
<code className="sig-name descname">checkout</code><span className="sig-paren">(</span><em className="sig-param">force: bool = False</em>, <em className="sig-param">layered: bool = False</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.image.Image.checkout" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks the image out, changing the current HEAD pointer. Raises an error
if there are pending changes to its checkout.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>force</strong> – Discards all pending changes to the schema.</p></li>
<li><p><strong>layered</strong> – If True, uses layered querying to check out the image (doesn’t materialize tables
inside of it).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.comment">
<em className="property">property </em><code className="sig-name descname">comment</code><a className="headerlink" href="#splitgraph.core.image.Image.comment" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 3</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.created">
<em className="property">property </em><code className="sig-name descname">created</code><a className="headerlink" href="#splitgraph.core.image.Image.created" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.delete_tag">
<code className="sig-name descname">delete_tag</code><span className="sig-paren">(</span><em className="sig-param">tag: str</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.image.Image.delete_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a tag from an image.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>tag</strong> – Tag to delete.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.engine">
<em className="property">property </em><code className="sig-name descname">engine</code><a className="headerlink" href="#splitgraph.core.image.Image.engine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.get_log">
<code className="sig-name descname">get_log</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → List[splitgraph.core.image.Image]<a className="headerlink" href="#splitgraph.core.image.Image.get_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeatedly gets the parent of a given image until it reaches the bottom.</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.get_parent_children">
<code className="sig-name descname">get_parent_children</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → Tuple[str, List[Any]]<a className="headerlink" href="#splitgraph.core.image.Image.get_parent_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the parent and a list of children of a given image.</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.get_size">
<code className="sig-name descname">get_size</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → int<a className="headerlink" href="#splitgraph.core.image.Image.get_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the physical size used by the image’s objects (including those that might be
shared with other images).</p>
<p>This is calculated from the metadata, the on-disk footprint might be smaller if not all of image’s
objects have been downloaded.</p>
<dl className="field-list simple">
<dt className="field-odd">Returns</dt>
<dd className="field-odd"><p>Size of the image in bytes.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.get_table">
<code className="sig-name descname">get_table</code><span className="sig-paren">(</span><em className="sig-param">table_name: str</em><span className="sig-paren">)</span> → splitgraph.core.table.Table<a className="headerlink" href="#splitgraph.core.image.Image.get_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Table object representing a version of a given table.
Contains a list of objects that the table is linked to and the table’s schema.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>table_name</strong> – Name of the table</p>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>Table object</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.get_tables">
<code className="sig-name descname">get_tables</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → List[str]<a className="headerlink" href="#splitgraph.core.image.Image.get_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the names of all tables inside of an image.</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.get_tags">
<code className="sig-name descname">get_tags</code><span className="sig-paren">(</span><span className="sig-paren">)</span><a className="headerlink" href="#splitgraph.core.image.Image.get_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists all tags that this image has.</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.image_hash">
<em className="property">property </em><code className="sig-name descname">image_hash</code><a className="headerlink" href="#splitgraph.core.image.Image.image_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.object_engine">
<em className="property">property </em><code className="sig-name descname">object_engine</code><a className="headerlink" href="#splitgraph.core.image.Image.object_engine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.parent_id">
<em className="property">property </em><code className="sig-name descname">parent_id</code><a className="headerlink" href="#splitgraph.core.image.Image.parent_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.provenance">
<code className="sig-name descname">provenance</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → List[Tuple[Repository, str]]<a className="headerlink" href="#splitgraph.core.image.Image.provenance" title="Permalink to this definition">¶</a></dt>
<dd><p>Inspects the image’s parent chain to come up with a set of repositories and their hashes
that it was created from.</p>
<dl className="field-list simple">
<dt className="field-odd">Returns</dt>
<dd className="field-odd"><p>List of (repository, image_hash)</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.provenance_data">
<em className="property">property </em><code className="sig-name descname">provenance_data</code><a className="headerlink" href="#splitgraph.core.image.Image.provenance_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 5</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.provenance_type">
<em className="property">property </em><code className="sig-name descname">provenance_type</code><a className="headerlink" href="#splitgraph.core.image.Image.provenance_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 4</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.query_schema">
<code className="sig-name descname">query_schema</code><span className="sig-paren">(</span><em className="sig-param">wrapper: Optional[str] = 'splitgraph.core.fdw_checkout.QueryingForeignDataWrapper'</em><span className="sig-paren">)</span> → Iterator[str]<a className="headerlink" href="#splitgraph.core.image.Image.query_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a temporary schema with tables in this image mounted as foreign tables that can be accessed via
read-only layered querying. On exit from the context manager, the schema is discarded.</p>
<dl className="field-list simple">
<dt className="field-odd">Returns</dt>
<dd className="field-odd"><p>The name of the schema the image is located in.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.repository">
<em className="property">property </em><code className="sig-name descname">repository</code><a className="headerlink" href="#splitgraph.core.image.Image.repository" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 6</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.set_provenance">
<code className="sig-name descname">set_provenance</code><span className="sig-paren">(</span><em className="sig-param">provenance_type: str</em>, <em className="sig-param">**kwargs</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.image.Image.set_provenance" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the image’s provenance. Internal function called by the Splitfile interpreter, shouldn’t
be called directly as it changes the image after it’s been created.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>provenance_type</strong> – One of “SQL”, “MOUNT”, “IMPORT” or “FROM”</p></li>
<li><p><strong>kwargs</strong> – Extra provenance-specific arguments</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.tag">
<code className="sig-name descname">tag</code><span className="sig-paren">(</span><em className="sig-param">tag: str</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.image.Image.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Tags a given image. All tags are unique inside of a repository. If a tag already exists, it’s removed
from the previous image and given to the new image.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>tag</strong> – Tag to set. ‘latest’ and ‘HEAD’ are reserved tags.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image.Image.to_splitfile">
<code className="sig-name descname">to_splitfile</code><span className="sig-paren">(</span><em className="sig-param">err_on_end: bool = True</em>, <em className="sig-param">source_replacement: Optional[Dict[Repository</em>, <em className="sig-param">str]] = None</em><span className="sig-paren">)</span> → List[str]<a className="headerlink" href="#splitgraph.core.image.Image.to_splitfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Crawls the image’s parent chain to recreates a Splitfile that can be used to reconstruct it.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>err_on_end</strong> – If False, when an image with no provenance is reached and it still has a parent, then instead
of raising an exception, it will base the Splitfile (using the FROM command) on that image.</p></li>
<li><p><strong>source_replacement</strong> – A dictionary of repositories and image hashes/tags specifying how to replace the
dependencies of this Splitfile (table imports and FROM commands).</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>A list of Splitfile commands that can be fed back into the executor.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl className="function">
<dt id="splitgraph.core.image.getrandbits">
<code className="sig-prename descclassname">splitgraph.core.image.</code><code className="sig-name descname">getrandbits</code><span className="sig-paren">(</span><em className="sig-param">k</em><span className="sig-paren">)</span> → x.  Generates an int with k random bits.<a className="headerlink" href="#splitgraph.core.image.getrandbits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div className="section" id="module-splitgraph.core.image_manager">
<span id="splitgraph-core-image-manager-module"></span><h2 id="splitgraphcoreimage_manager-module">splitgraph.core.image_manager module<a className="headerlink" href="#module-splitgraph.core.image_manager" title="Permalink to this headline">¶</a></h2>
<dl className="class">
<dt id="splitgraph.core.image_manager.ImageManager">
<em className="property">class </em><code className="sig-prename descclassname">splitgraph.core.image_manager.</code><code className="sig-name descname">ImageManager</code><span className="sig-paren">(</span><em className="sig-param">repository: Repository</em><span className="sig-paren">)</span><a className="headerlink" href="#splitgraph.core.image_manager.ImageManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code className="xref py py-class docutils literal notranslate"><span className="pre">object</span></code></p>
<p>Collects various image-related functions.</p>
<dl className="method">
<dt id="splitgraph.core.image_manager.ImageManager.add">
<code className="sig-name descname">add</code><span className="sig-paren">(</span><em className="sig-param">parent_id: Optional[str], image: str, created: Optional[datetime.datetime] = None, comment: Optional[str] = None, provenance_type: Optional[str] = None, provenance_data: Union[Dict[str, Union[str, List[str], List[bool]]], str, None] = None</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.image_manager.ImageManager.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a new image in the Splitgraph image tree.</p>
<p>Internal method used by actual image creation routines (committing, importing or pulling).</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>parent_id</strong> – Parent of the image</p></li>
<li><p><strong>image</strong> – Image hash</p></li>
<li><p><strong>created</strong> – Creation time (defaults to current timestamp)</p></li>
<li><p><strong>comment</strong> – Comment (defaults to empty)</p></li>
<li><p><strong>provenance_type</strong> – Image provenance that can be used to rebuild the image
(one of None, FROM, MOUNT, IMPORT, SQL)</p></li>
<li><p><strong>provenance_data</strong> – Extra provenance data (dictionary).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image_manager.ImageManager.by_hash">
<code className="sig-name descname">by_hash</code><span className="sig-paren">(</span><em className="sig-param">image_hash: str</em><span className="sig-paren">)</span> → splitgraph.core.image.Image<a className="headerlink" href="#splitgraph.core.image_manager.ImageManager.by_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an image corresponding to a given (possibly shortened) image hash. If the image hash
is ambiguous, raises an error. If the image does not exist, raises an error or returns None.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>image_hash</strong> – Image hash (can be shortened).</p>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>Image</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image_manager.ImageManager.by_tag">
<code className="sig-name descname">by_tag</code><span className="sig-paren">(</span><em className="sig-param">tag: str</em>, <em className="sig-param">raise_on_none: bool = True</em><span className="sig-paren">)</span> → Optional[splitgraph.core.image.Image]<a className="headerlink" href="#splitgraph.core.image_manager.ImageManager.by_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an image with a given tag</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>tag</strong> – Tag. ‘latest’ is a special case: it returns the most recent image in the repository.</p></li>
<li><p><strong>raise_on_none</strong> – Whether to raise an error or return None if the tag doesn’t exist.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image_manager.ImageManager.delete">
<code className="sig-name descname">delete</code><span className="sig-paren">(</span><em className="sig-param">images: Set[str]</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.image_manager.ImageManager.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a set of Splitgraph images from the repository. Note this doesn’t check whether
this will orphan some other images in the repository and can make the state of the repository
invalid.</p>
<p>Image deletions won’t be replicated on push/pull (those can only add new images).</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>images</strong> – List of image IDs</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image_manager.ImageManager.get_all_child_images">
<code className="sig-name descname">get_all_child_images</code><span className="sig-paren">(</span><em className="sig-param">start_image: str</em><span className="sig-paren">)</span> → Set[str]<a className="headerlink" href="#splitgraph.core.image_manager.ImageManager.get_all_child_images" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all children of <cite>start_image</cite> of any degree.</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.image_manager.ImageManager.get_all_parent_images">
<code className="sig-name descname">get_all_parent_images</code><span className="sig-paren">(</span><em className="sig-param">start_images: Set[str]</em><span className="sig-paren">)</span> → Set[str]<a className="headerlink" href="#splitgraph.core.image_manager.ImageManager.get_all_parent_images" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all parents of the ‘start_images’ set of any degree.</p>
</dd></dl>

</dd></dl>

</div>
<div className="section" id="module-splitgraph.core.metadata_manager">
<span id="splitgraph-core-metadata-manager-module"></span><h2 id="splitgraphcoremetadata_manager-module">splitgraph.core.metadata_manager module<a className="headerlink" href="#module-splitgraph.core.metadata_manager" title="Permalink to this headline">¶</a></h2>
<p>Classes related to managing table/image/object metadata tables.</p>
<dl className="class">
<dt id="splitgraph.core.metadata_manager.MetadataManager">
<em className="property">class </em><code className="sig-prename descclassname">splitgraph.core.metadata_manager.</code><code className="sig-name descname">MetadataManager</code><span className="sig-paren">(</span><em className="sig-param">metadata_engine: PostgresEngine</em><span className="sig-paren">)</span><a className="headerlink" href="#splitgraph.core.metadata_manager.MetadataManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code className="xref py py-class docutils literal notranslate"><span className="pre">object</span></code></p>
<p>A data access layer for the metadata tables in the splitgraph_meta schema that concerns itself
with image, table and object information.</p>
<dl className="method">
<dt id="splitgraph.core.metadata_manager.MetadataManager.cleanup_metadata">
<code className="sig-name descname">cleanup_metadata</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → Set[str]<a className="headerlink" href="#splitgraph.core.metadata_manager.MetadataManager.cleanup_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Go through the current metadata and delete all objects that aren’t required
by any table on the engine.</p>
<dl className="field-list simple">
<dt className="field-odd">Returns</dt>
<dd className="field-odd"><p>List of objects that are still required.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.metadata_manager.MetadataManager.get_all_objects">
<code className="sig-name descname">get_all_objects</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → List[str]<a className="headerlink" href="#splitgraph.core.metadata_manager.MetadataManager.get_all_objects" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets all objects currently in the Splitgraph tree.</p>
<dl className="field-list simple">
<dt className="field-odd">Returns</dt>
<dd className="field-odd"><p>List of object IDs.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.metadata_manager.MetadataManager.get_external_object_locations">
<code className="sig-name descname">get_external_object_locations</code><span className="sig-paren">(</span><em className="sig-param">objects: List[str]</em><span className="sig-paren">)</span> → List[Tuple[str, str, str]]<a className="headerlink" href="#splitgraph.core.metadata_manager.MetadataManager.get_external_object_locations" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets external locations for objects.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>objects</strong> – List of object IDs stored externally.</p>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>List of (object_id, location, protocol).</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.metadata_manager.MetadataManager.get_new_objects">
<code className="sig-name descname">get_new_objects</code><span className="sig-paren">(</span><em className="sig-param">object_ids: List[str]</em><span className="sig-paren">)</span> → List[str]<a className="headerlink" href="#splitgraph.core.metadata_manager.MetadataManager.get_new_objects" title="Permalink to this definition">¶</a></dt>
<dd><p>Get object IDs from the passed list that don’t exist in the tree.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>object_ids</strong> – List of objects to check</p>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>List of unknown object IDs.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.metadata_manager.MetadataManager.get_object_meta">
<code className="sig-name descname">get_object_meta</code><span className="sig-paren">(</span><em className="sig-param">objects: List[str]</em><span className="sig-paren">)</span> → Dict[str, splitgraph.core.metadata_manager.Object]<a className="headerlink" href="#splitgraph.core.metadata_manager.MetadataManager.get_object_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>Get metadata for multiple Splitgraph objects from the tree</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>objects</strong> – List of objects to get metadata for.</p>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>Dictionary of object_id -> Object</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.metadata_manager.MetadataManager.get_objects_for_repository">
<code className="sig-name descname">get_objects_for_repository</code><span className="sig-paren">(</span><em className="sig-param">repository: Repository</em><span className="sig-paren">)</span> → List[str]<a className="headerlink" href="#splitgraph.core.metadata_manager.MetadataManager.get_objects_for_repository" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl className="method">
<dt id="splitgraph.core.metadata_manager.MetadataManager.register_object_locations">
<code className="sig-name descname">register_object_locations</code><span className="sig-paren">(</span><em className="sig-param">object_locations: List[Tuple[str, str, str]]</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.metadata_manager.MetadataManager.register_object_locations" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers external locations (e.g. HTTP or S3) for Splitgraph objects.
Objects must already be registered in the object tree.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>object_locations</strong> – List of (object_id, location, protocol).</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.metadata_manager.MetadataManager.register_objects">
<code className="sig-name descname">register_objects</code><span className="sig-paren">(</span><em className="sig-param">objects: List[splitgraph.core.metadata_manager.Object], namespace: Optional[str] = None</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.metadata_manager.MetadataManager.register_objects" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers multiple Splitgraph objects in the tree.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>objects</strong> – List of <cite>Object</cite> objects.</p></li>
<li><p><strong>namespace</strong> – If specified, overrides the original object namespace, required
in the case where the remote repository has a different namespace than the local one.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.metadata_manager.MetadataManager.register_tables">
<code className="sig-name descname">register_tables</code><span className="sig-paren">(</span><em className="sig-param">repository: Repository, table_meta: List[Tuple[str, str, List[splitgraph.core.types.TableColumn], List[str]]]</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.metadata_manager.MetadataManager.register_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Links tables in an image to physical objects that they are stored as.
Objects must already be registered in the object tree.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>repository</strong> – Repository that the tables belong to.</p></li>
<li><p><strong>table_meta</strong> – A list of (image_hash, table_name, table_schema, object_ids).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl className="class">
<dt id="splitgraph.core.metadata_manager.Object">
<em className="property">class </em><code className="sig-prename descclassname">splitgraph.core.metadata_manager.</code><code className="sig-name descname">Object</code><a className="headerlink" href="#splitgraph.core.metadata_manager.Object" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code className="xref py py-class docutils literal notranslate"><span className="pre">tuple</span></code></p>
<p>Represents a Splitgraph object that tables are composed of.</p>
<dl className="method">
<dt id="splitgraph.core.metadata_manager.Object.created">
<em className="property">property </em><code className="sig-name descname">created</code><a className="headerlink" href="#splitgraph.core.metadata_manager.Object.created" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 4</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.metadata_manager.Object.deletion_hash">
<em className="property">property </em><code className="sig-name descname">deletion_hash</code><a className="headerlink" href="#splitgraph.core.metadata_manager.Object.deletion_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 6</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.metadata_manager.Object.format">
<em className="property">property </em><code className="sig-name descname">format</code><a className="headerlink" href="#splitgraph.core.metadata_manager.Object.format" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.metadata_manager.Object.insertion_hash">
<em className="property">property </em><code className="sig-name descname">insertion_hash</code><a className="headerlink" href="#splitgraph.core.metadata_manager.Object.insertion_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 5</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.metadata_manager.Object.namespace">
<em className="property">property </em><code className="sig-name descname">namespace</code><a className="headerlink" href="#splitgraph.core.metadata_manager.Object.namespace" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.metadata_manager.Object.object_id">
<em className="property">property </em><code className="sig-name descname">object_id</code><a className="headerlink" href="#splitgraph.core.metadata_manager.Object.object_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.metadata_manager.Object.object_index">
<em className="property">property </em><code className="sig-name descname">object_index</code><a className="headerlink" href="#splitgraph.core.metadata_manager.Object.object_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 7</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.metadata_manager.Object.size">
<em className="property">property </em><code className="sig-name descname">size</code><a className="headerlink" href="#splitgraph.core.metadata_manager.Object.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 3</p>
</dd></dl>

</dd></dl>

</div>
<div className="section" id="module-splitgraph.core.object_manager">
<span id="splitgraph-core-object-manager-module"></span><h2 id="splitgraphcoreobject_manager-module">splitgraph.core.object_manager module<a className="headerlink" href="#module-splitgraph.core.object_manager" title="Permalink to this headline">¶</a></h2>
<p>Functions related to creating, deleting and keeping track of physical Splitgraph objects.</p>
<dl className="class">
<dt id="splitgraph.core.object_manager.ObjectManager">
<em className="property">class </em><code className="sig-prename descclassname">splitgraph.core.object_manager.</code><code className="sig-name descname">ObjectManager</code><span className="sig-paren">(</span><em className="sig-param">object_engine: PostgresEngine</em>, <em className="sig-param">metadata_engine: Optional[PostgresEngine] = None</em><span className="sig-paren">)</span><a className="headerlink" href="#splitgraph.core.object_manager.ObjectManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a className="reference internal" href="#splitgraph.core.fragment_manager.FragmentManager" title="splitgraph.core.fragment_manager.FragmentManager"><code className="xref py py-class docutils literal notranslate"><span className="pre">splitgraph.core.fragment_manager.FragmentManager</span></code></a></p>
<p>Brings the multiple manager classes together and manages the object cache (downloading and uploading
objects as required in order to fulfill certain queries)</p>
<dl className="method">
<dt id="splitgraph.core.object_manager.ObjectManager.cleanup">
<code className="sig-name descname">cleanup</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → Set[str]<a className="headerlink" href="#splitgraph.core.object_manager.ObjectManager.cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes all objects in the object_tree not required by any current repository, including their dependencies and
their remote locations. Also deletes all objects not registered in the object_tree.</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.object_manager.ObjectManager.download_objects">
<code className="sig-name descname">download_objects</code><span className="sig-paren">(</span><em className="sig-param">source: Optional[ObjectManager], objects_to_fetch: List[str], object_locations: List[Tuple[str, str, str]]</em><span className="sig-paren">)</span> → List[str]<a className="headerlink" href="#splitgraph.core.object_manager.ObjectManager.download_objects" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetches the required objects from the remote and stores them locally.
Does nothing for objects that already exist.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>source</strong> – Remote ObjectManager. If None, will only try to download objects from the external location.</p></li>
<li><p><strong>objects_to_fetch</strong> – List of object IDs to download.</p></li>
<li><p><strong>object_locations</strong> – List of custom object locations, encoded as tuples (object_id, object_url, protocol).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.object_manager.ObjectManager.ensure_objects">
<code className="sig-name descname">ensure_objects</code><span className="sig-paren">(</span><em className="sig-param">table: Optional[Table], objects: Optional[List[str]] = None, quals: Optional[Sequence[Sequence[Tuple[str, str, Any]]]] = None, defer_release: bool = False, tracer: Optional[splitgraph.core.common.Tracer] = None, upstream_manager: Optional[ObjectManager] = None</em><span className="sig-paren">)</span> → Iterator[Union[List[str], Tuple[List[str], splitgraph.core.common.CallbackList]]]<a className="headerlink" href="#splitgraph.core.object_manager.ObjectManager.ensure_objects" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolves the objects needed to materialize a given table and makes sure they are in the local
splitgraph_meta schema.</p>
<p>Whilst inside this manager, the objects are guaranteed to exist. On exit from it, the objects are marked as
unneeded and can be garbage collected.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>table</strong> – Table to materialize</p></li>
<li><p><strong>objects</strong> – List of objects to download: one of table or objects must be specified.</p></li>
<li><p><strong>quals</strong> – Optional list of qualifiers to be passed to the fragment engine. Fragments that definitely do
not match these qualifiers will be dropped. See the docstring for <cite>filter_fragments</cite> for the format.</p></li>
<li><p><strong>defer_release</strong> – If True, won’t release the objects on exit.</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>If defer_release is True: List of table fragments and a callback that the caller must call
when the objects are no longer needed. If defer_release is False: just the list of table fragments.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.object_manager.ObjectManager.get_cache_occupancy">
<code className="sig-name descname">get_cache_occupancy</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → int<a className="headerlink" href="#splitgraph.core.object_manager.ObjectManager.get_cache_occupancy" title="Permalink to this definition">¶</a></dt>
<dd><dl className="field-list simple">
<dt className="field-odd">Returns</dt>
<dd className="field-odd"><p>Space occupied by objects cached from external locations, in bytes.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.object_manager.ObjectManager.get_downloaded_objects">
<code className="sig-name descname">get_downloaded_objects</code><span className="sig-paren">(</span><em className="sig-param">limit_to: Optional[List[str]] = None</em><span className="sig-paren">)</span> → List[str]<a className="headerlink" href="#splitgraph.core.object_manager.ObjectManager.get_downloaded_objects" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a list of objects currently in the Splitgraph cache (i.e. not only existing externally.)</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>limit_to</strong> – If specified, only the objects in this list will be returned.</p>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>Set of object IDs.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.object_manager.ObjectManager.get_total_object_size">
<code className="sig-name descname">get_total_object_size</code><span className="sig-paren">(</span><span className="sig-paren">)</span><a className="headerlink" href="#splitgraph.core.object_manager.ObjectManager.get_total_object_size" title="Permalink to this definition">¶</a></dt>
<dd><dl className="field-list simple">
<dt className="field-odd">Returns</dt>
<dd className="field-odd"><p>Space occupied by all objects on the engine, in bytes.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.object_manager.ObjectManager.make_objects_external">
<code className="sig-name descname">make_objects_external</code><span className="sig-paren">(</span><em className="sig-param">objects: List[str], handler: str, handler_params: Dict[Any, Any]</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.object_manager.ObjectManager.make_objects_external" title="Permalink to this definition">¶</a></dt>
<dd><p>Uploads local objects to an external location and marks them as being cached locally (thus making it possible
to evict or swap them out).</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>objects</strong> – Object IDs to upload. Will do nothing for objects that already exist externally.</p></li>
<li><p><strong>handler</strong> – Object handler</p></li>
<li><p><strong>handler_params</strong> – Extra handler parameters</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.object_manager.ObjectManager.run_eviction">
<code className="sig-name descname">run_eviction</code><span className="sig-paren">(</span><em className="sig-param">keep_objects: List[str], required_space: Optional[int] = None</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.object_manager.ObjectManager.run_eviction" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete enough objects with zero reference count (only those, since we guarantee that whilst refcount is >0,
the object stays alive) to free at least <cite>required_space</cite> in the cache.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>keep_objects</strong> – List of objects (besides those with nonzero refcount) that can’t be deleted.</p></li>
<li><p><strong>required_space</strong> – Space, in bytes, to free. If the routine can’t free at least this much space,
it shall raise an exception. If None, removes all eligible objects.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.object_manager.ObjectManager.upload_objects">
<code className="sig-name descname">upload_objects</code><span className="sig-paren">(</span><em className="sig-param">target: splitgraph.core.object_manager.ObjectManager, objects_to_push: List[str], handler: str = 'DB', handler_params: Optional[Dict[Any, Any]] = None</em><span className="sig-paren">)</span> → List[Tuple[str, str, str]]<a className="headerlink" href="#splitgraph.core.object_manager.ObjectManager.upload_objects" title="Permalink to this definition">¶</a></dt>
<dd><p>Uploads physical objects to the remote or some other external location.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>target</strong> – Target ObjectManager</p></li>
<li><p><strong>objects_to_push</strong> – List of object IDs to upload.</p></li>
<li><p><strong>handler</strong> – Name of the handler to use to upload objects. Use <cite>DB</cite> to push them to the remote, <cite>FILE</cite>
to store them in a directory that can be accessed from the client and <cite>HTTP</cite> to upload them to HTTP.</p></li>
<li><p><strong>handler_params</strong> – For <cite>HTTP</cite>, a dictionary <cite>&#38;lbrace;“username”: username, “password”, password&#38;rbrace;</cite>. For <cite>FILE</cite>,
a dictionary <cite>&#38;lbrace;“path”: path&#38;rbrace;</cite> specifying the directory where the objects shall be saved.</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>A list of (object_id, url, handler) that specifies all objects were uploaded (skipping objects that
already exist on the remote).</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div className="section" id="module-splitgraph.core.registry">
<span id="splitgraph-core-registry-module"></span><h2 id="splitgraphcoreregistry-module">splitgraph.core.registry module<a className="headerlink" href="#module-splitgraph.core.registry" title="Permalink to this headline">¶</a></h2>
<p>Functions for communicating with the remote Splitgraph catalog</p>
<dl className="class">
<dt id="splitgraph.core.registry.PublishInfo">
<em className="property">class </em><code className="sig-prename descclassname">splitgraph.core.registry.</code><code className="sig-name descname">PublishInfo</code><span className="sig-paren">(</span><em className="sig-param">image_hash</em>, <em className="sig-param">published</em>, <em className="sig-param">provenance</em>, <em className="sig-param">readme</em>, <em className="sig-param">schemata</em>, <em className="sig-param">previews</em><span className="sig-paren">)</span><a className="headerlink" href="#splitgraph.core.registry.PublishInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code className="xref py py-class docutils literal notranslate"><span className="pre">tuple</span></code></p>
<dl className="method">
<dt id="splitgraph.core.registry.PublishInfo.image_hash">
<em className="property">property </em><code className="sig-name descname">image_hash</code><a className="headerlink" href="#splitgraph.core.registry.PublishInfo.image_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.registry.PublishInfo.previews">
<em className="property">property </em><code className="sig-name descname">previews</code><a className="headerlink" href="#splitgraph.core.registry.PublishInfo.previews" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 5</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.registry.PublishInfo.provenance">
<em className="property">property </em><code className="sig-name descname">provenance</code><a className="headerlink" href="#splitgraph.core.registry.PublishInfo.provenance" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.registry.PublishInfo.published">
<em className="property">property </em><code className="sig-name descname">published</code><a className="headerlink" href="#splitgraph.core.registry.PublishInfo.published" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.registry.PublishInfo.readme">
<em className="property">property </em><code className="sig-name descname">readme</code><a className="headerlink" href="#splitgraph.core.registry.PublishInfo.readme" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 3</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.registry.PublishInfo.schemata">
<em className="property">property </em><code className="sig-name descname">schemata</code><a className="headerlink" href="#splitgraph.core.registry.PublishInfo.schemata" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 4</p>
</dd></dl>

</dd></dl>

<dl className="function">
<dt id="splitgraph.core.registry.get_info_key">
<code className="sig-prename descclassname">splitgraph.core.registry.</code><code className="sig-name descname">get_info_key</code><span className="sig-paren">(</span><em className="sig-param">engine: PostgresEngine</em>, <em className="sig-param">key: str</em><span className="sig-paren">)</span> → Optional[str]<a className="headerlink" href="#splitgraph.core.registry.get_info_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a configuration key from the remote registry, used to notify the client of the registry’s capabilities.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>engine</strong> – Engine</p></li>
<li><p><strong>key</strong> – Key to get</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.registry.get_published_info">
<code className="sig-prename descclassname">splitgraph.core.registry.</code><code className="sig-name descname">get_published_info</code><span className="sig-paren">(</span><em className="sig-param">repository: Repository</em>, <em className="sig-param">tag: str</em><span className="sig-paren">)</span> → Optional[splitgraph.core.registry.PublishInfo]<a className="headerlink" href="#splitgraph.core.registry.get_published_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Get information on an image that’s published in a catalog.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>repository</strong> – Repository</p></li>
<li><p><strong>tag</strong> – Image tag</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>A PublishInfo namedtuple.</p>
</dd>
</dl>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.registry.publish_tag">
<code className="sig-prename descclassname">splitgraph.core.registry.</code><code className="sig-name descname">publish_tag</code><span className="sig-paren">(</span><em className="sig-param">repository: Repository</em>, <em className="sig-param">tag: str</em>, <em className="sig-param">info: splitgraph.core.registry.PublishInfo</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.registry.publish_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Publishes a given tag in the remote catalog. Should’t be called directly.
Use splitgraph.commands.publish instead.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>repository</strong> – Remote (!) Repository object</p></li>
<li><p><strong>tag</strong> – Tag to publish</p></li>
<li><p><strong>info</strong> – A structure with information about the published image.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.registry.set_info_key">
<code className="sig-prename descclassname">splitgraph.core.registry.</code><code className="sig-name descname">set_info_key</code><span className="sig-paren">(</span><em className="sig-param">engine: PostgresEngine, key: str, value: Union[bool, str]</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.registry.set_info_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets a configuration value on the remote registry.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>engine</strong> – Engine</p></li>
<li><p><strong>key</strong> – Key to set</p></li>
<li><p><strong>value</strong> – New value for the key</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.registry.setup_registry_mode">
<code className="sig-prename descclassname">splitgraph.core.registry.</code><code className="sig-name descname">setup_registry_mode</code><span className="sig-paren">(</span><em className="sig-param">engine: PostgresEngine</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.registry.setup_registry_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Drops tables in splitgraph_meta that aren’t pertinent to the registry + sets up access policies/RLS:</p>
<ul className="simple">
<li><p>Normal users aren’t allowed to create tables/schemata (can’t do checkouts inside of a registry or
upload SG objects directly to it)</p></li>
<li><p>Normal users can’t access the splitgraph_meta schema directly: they’re only supposed to be able to
talk to it via stored procedures in splitgraph_api. Those procedures are set up with SECURITY INVOKER
(run with those users’ credentials) and what they can access is further restricted by RLS:</p>
<ul>
<li><p>images/tables/tags meta tables: can only create/update/delete records where the namespace = user ID</p></li>
<li><p>objects/object_location tables: same. An object (piece of data) becomes owned by the user that creates
it and still remains so even if someone else’s image starts using it. Hence, the original owner can delete
or change it (since they control the external location they’ve uploaded it to anyway).</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.registry.toggle_registry_rls">
<code className="sig-prename descclassname">splitgraph.core.registry.</code><code className="sig-name descname">toggle_registry_rls</code><span className="sig-paren">(</span><em className="sig-param">engine: PostgresEngine</em>, <em className="sig-param">mode: str = 'ENABLE'</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.registry.toggle_registry_rls" title="Permalink to this definition">¶</a></dt>
<dd><p>Switches row-level security on the registry, restricting write access to metadata tables
to owners of relevant repositories/objects.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>engine</strong> – Engine</p></li>
<li><p><strong>mode</strong> – ENABLE, DISABLE or FORCE (enable for superusers/table owners)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.registry.unpublish_repository">
<code className="sig-prename descclassname">splitgraph.core.registry.</code><code className="sig-name descname">unpublish_repository</code><span className="sig-paren">(</span><em className="sig-param">repository: Repository</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.registry.unpublish_repository" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes the repository from the remote catalog.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>repository</strong> – Repository to unpublish</p>
</dd>
</dl>
</dd></dl>

</div>
<div className="section" id="module-splitgraph.core.repository">
<span id="splitgraph-core-repository-module"></span><h2 id="splitgraphcorerepository-module">splitgraph.core.repository module<a className="headerlink" href="#module-splitgraph.core.repository" title="Permalink to this headline">¶</a></h2>
<p>Public API for managing images in a Splitgraph repository.</p>
<dl className="class">
<dt id="splitgraph.core.repository.Repository">
<em className="property">class </em><code className="sig-prename descclassname">splitgraph.core.repository.</code><code className="sig-name descname">Repository</code><span className="sig-paren">(</span><em className="sig-param">namespace: str</em>, <em className="sig-param">repository: str</em>, <em className="sig-param">engine: Optional[splitgraph.engine.postgres.engine.PostgresEngine] = None</em>, <em className="sig-param">object_engine: Optional[splitgraph.engine.postgres.engine.PostgresEngine] = None</em>, <em className="sig-param">object_manager: Optional[splitgraph.core.object_manager.ObjectManager] = None</em><span className="sig-paren">)</span><a className="headerlink" href="#splitgraph.core.repository.Repository" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code className="xref py py-class docutils literal notranslate"><span className="pre">object</span></code></p>
<p>Splitgraph repository API</p>
<dl className="method">
<dt id="splitgraph.core.repository.Repository.commit">
<code className="sig-name descname">commit</code><span className="sig-paren">(</span><em className="sig-param">image_hash: Optional[str] = None</em>, <em className="sig-param">comment: Optional[str] = None</em>, <em className="sig-param">snap_only: bool = False</em>, <em className="sig-param">chunk_size: Optional[int] = 10000</em>, <em className="sig-param">split_changeset: bool = False</em>, <em className="sig-param">extra_indexes: Optional[Dict[str</em>, <em className="sig-param">Dict[str</em>, <em className="sig-param">Dict[str</em>, <em className="sig-param">Any]]]] = None</em><span className="sig-paren">)</span> → splitgraph.core.image.Image<a className="headerlink" href="#splitgraph.core.repository.Repository.commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Commits all pending changes to a given repository, creating a new image.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>image_hash</strong> – Hash of the commit. Chosen by random if unspecified.</p></li>
<li><p><strong>comment</strong> – Optional comment to add to the commit.</p></li>
<li><p><strong>snap_only</strong> – If True, will store the table as a full snapshot instead of delta compression</p></li>
<li><p><strong>chunk_size</strong> – For tables that are stored as snapshots (new tables and where <cite>snap_only</cite> has been passed,
the table will be split into fragments of this many rows.</p></li>
<li><p><strong>split_changeset</strong> – If True, splits the changeset into multiple fragments based on
the PK regions spanned by the current table fragments. For example, if the original table
consists of 2 fragments, first spanning rows 1-10000, second spanning rows 10001-20000 and the
change alters rows 1, 10001 and inserts a row with PK 20001, this will record the change as
3 fragments: one inheriting from the first original fragment, one inheriting from the second
and a brand new fragment. This increases the number of fragments in total but means that fewer rows
will need to be scanned to satisfy a query.
If False, the changeset will be stored as a single fragment inheriting from the last fragment in the
table.</p></li>
<li><p><strong>extra_indexes</strong> – Dictionary of &#38;lbrace;table: index_type: column: index_specific_kwargs&#38;rbrace;.</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>The newly created Image object.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.commit_engines">
<code className="sig-name descname">commit_engines</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.repository.Repository.commit_engines" title="Permalink to this definition">¶</a></dt>
<dd><p>Commit the underlying transactions on both engines that the repository uses.</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.delete">
<code className="sig-name descname">delete</code><span className="sig-paren">(</span><em className="sig-param">unregister: bool = True</em>, <em className="sig-param">uncheckout: bool = True</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.repository.Repository.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Discards all changes to a given repository and optionally all of its history,
as well as deleting the Postgres schema that it might be checked out into.
Doesn’t delete any cached physical objects.</p>
<p>After performing this operation, this object becomes invalid and must be discarded,
unless init() is called again.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>unregister</strong> – Whether to purge repository history/metadata</p></li>
<li><p><strong>uncheckout</strong> – Whether to delete the actual checked out repo</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.diff">
<code className="sig-name descname">diff</code><span className="sig-paren">(</span><em className="sig-param">table_name: str, image_1: Union[splitgraph.core.image.Image, str], image_2: Union[splitgraph.core.image.Image, str, None], aggregate: bool = False</em><span className="sig-paren">)</span> → Union[bool, Tuple[int, int, int], List[Tuple[bool, Tuple]]]<a className="headerlink" href="#splitgraph.core.repository.Repository.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares the state of a table in different images by materializing both tables into a temporary space
and comparing them row-to-row.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>table_name</strong> – Name of the table.</p></li>
<li><p><strong>image_1</strong> – First image hash / object. If None, uses the state of the current staging area.</p></li>
<li><p><strong>image_2</strong> – Second image hash / object. If None, uses the state of the current staging area.</p></li>
<li><p><strong>aggregate</strong> – If True, returns a tuple of integers denoting added, removed and updated rows between
the two images.</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>If the table doesn’t exist in one of the images, returns True if it was added and False if it was
removed. If <cite>aggregate</cite> is True, returns the aggregation of changes as specified before.
Otherwise, returns a list of changes where each change is a tuple of
<cite>(True for added, False for removed, row contents)</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.dump">
<code className="sig-name descname">dump</code><span className="sig-paren">(</span><em className="sig-param">stream: _io.TextIOWrapper</em>, <em className="sig-param">exclude_object_contents: bool = False</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.repository.Repository.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an SQL dump with the metadata required for the repository and all of its objects.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>stream</strong> – Stream to dump the data into.</p></li>
<li><p><strong>exclude_object_contents</strong> – Only dump the metadata but not the actual object contents.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.from_schema">
<em className="property">classmethod </em><code className="sig-name descname">from_schema</code><span className="sig-paren">(</span><em className="sig-param">schema: str</em><span className="sig-paren">)</span> → splitgraph.core.repository.Repository<a className="headerlink" href="#splitgraph.core.repository.Repository.from_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Postgres schema name of the format <cite>namespace/repository</cite> to a Splitgraph repository object.</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.from_template">
<em className="property">classmethod </em><code className="sig-name descname">from_template</code><span className="sig-paren">(</span><em className="sig-param">template: splitgraph.core.repository.Repository</em>, <em className="sig-param">namespace: Optional[str] = None</em>, <em className="sig-param">repository: None = None</em>, <em className="sig-param">engine: Optional[splitgraph.engine.postgres.engine.PostgresEngine] = None</em>, <em className="sig-param">object_engine: Optional[splitgraph.engine.postgres.engine.PostgresEngine] = None</em><span className="sig-paren">)</span> → splitgraph.core.repository.Repository<a className="headerlink" href="#splitgraph.core.repository.Repository.from_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Repository from an existing one replacing some of its attributes.</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.get_all_hashes_tags">
<code className="sig-name descname">get_all_hashes_tags</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → List[Tuple[Optional[str], str]]<a className="headerlink" href="#splitgraph.core.repository.Repository.get_all_hashes_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets all tagged images and their hashes in a given repository.</p>
<dl className="field-list simple">
<dt className="field-odd">Returns</dt>
<dd className="field-odd"><p>List of (image_hash, tag)</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.has_pending_changes">
<code className="sig-name descname">has_pending_changes</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → bool<a className="headerlink" href="#splitgraph.core.repository.Repository.has_pending_changes" title="Permalink to this definition">¶</a></dt>
<dd><p>Detects if the repository has any pending changes (schema changes, table additions/deletions, content changes).</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.head">
<em className="property">property </em><code className="sig-name descname">head</code><a className="headerlink" href="#splitgraph.core.repository.Repository.head" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the HEAD image for the repository or None if the repository isn’t checked out.</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.head_strict">
<em className="property">property </em><code className="sig-name descname">head_strict</code><a className="headerlink" href="#splitgraph.core.repository.Repository.head_strict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the HEAD image for the repository. Raise an exception if the repository
isn’t checked out.</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.import_tables">
<code className="sig-name descname">import_tables</code><span className="sig-paren">(</span><em className="sig-param">tables: Sequence[str], source_repository: Repository, source_tables: Sequence[str], image_hash: Optional[str] = None, foreign_tables: bool = False, do_checkout: bool = True, target_hash: Optional[str] = None, table_queries: Optional[Sequence[bool]] = None, parent_hash: Optional[str] = None, wrapper: Optional[str] = 'splitgraph.core.fdw_checkout.QueryingForeignDataWrapper'</em><span className="sig-paren">)</span> → str<a className="headerlink" href="#splitgraph.core.repository.Repository.import_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new commit in target_repository with one or more tables linked to already-existing tables.
After this operation, the HEAD of the target repository moves to the new commit and the new tables are
materialized.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>tables</strong> – If not empty, must be the list of the same length as <cite>source_tables</cite> specifying names to store
them under in the target repository.</p></li>
<li><p><strong>source_repository</strong> – Repository to import tables from.</p></li>
<li><p><strong>source_tables</strong> – List of tables to import. If empty, imports all tables.</p></li>
<li><p><strong>image_hash</strong> – Image hash in the source repository to import tables from.
Uses the current source HEAD by default.</p></li>
<li><p><strong>foreign_tables</strong> – If True, copies all source tables to create a series of new snapshots instead of
treating them as Splitgraph-versioned tables. This is useful for adding brand new tables
(for example, from an FDW-mounted table).</p></li>
<li><p><strong>do_checkout</strong> – If False, doesn’t check out the newly created image.</p></li>
<li><p><strong>target_hash</strong> – Hash of the new image that tables is recorded under. If None, gets chosen at random.</p></li>
<li><p><strong>table_queries</strong> – If not [], it’s treated as a Boolean mask showing which entries in the <cite>tables</cite> list are
instead SELECT SQL queries that form the target table. The queries have to be non-schema qualified and work
only against tables in the source repository. Each target table created is the result of the respective SQL
query. This is committed as a new snapshot.</p></li>
<li><p><strong>parent_hash</strong> – If not None, must be the hash of the image to base the new image on.
Existing tables from the parent image are preserved in the new image. If None, the current repository
HEAD is used.</p></li>
<li><p><strong>wrapper</strong> – Override the default class for the layered querying foreign data wrapper.</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>Hash that the new image was stored under.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.init">
<code className="sig-name descname">init</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.repository.Repository.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes an empty repo with an initial commit (hash 0000…)</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.materialized_table">
<code className="sig-name descname">materialized_table</code><span className="sig-paren">(</span><em className="sig-param">table_name: str, image_hash: Optional[str]</em><span className="sig-paren">)</span> → Iterator[Tuple[str, str]]<a className="headerlink" href="#splitgraph.core.repository.Repository.materialized_table" title="Permalink to this definition">¶</a></dt>
<dd><p>A context manager that returns a pointer to a read-only materialized table in a given image.
The table is deleted on exit from the context manager.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>table_name</strong> – Name of the table</p></li>
<li><p><strong>image_hash</strong> – Image hash to materialize</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>(schema, table_name) where the materialized table is located.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.publish">
<code className="sig-name descname">publish</code><span className="sig-paren">(</span><em className="sig-param">tag: str</em>, <em className="sig-param">remote_repository: Optional[Repository] = None</em>, <em className="sig-param">readme: str = ''</em>, <em className="sig-param">include_provenance: bool = True</em>, <em className="sig-param">include_table_previews: bool = True</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.repository.Repository.publish" title="Permalink to this definition">¶</a></dt>
<dd><p>Summarizes the data on a previously-pushed repository and makes it available in the catalog.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>tag</strong> – Image tag. Only images with tags can be published.</p></li>
<li><p><strong>remote_repository</strong> – Remote Repository object (uses the upstream if unspecified)</p></li>
<li><p><strong>readme</strong> – Optional README for the repository.</p></li>
<li><p><strong>include_provenance</strong> – If False, doesn’t include the dependencies of the image</p></li>
<li><p><strong>include_table_previews</strong> – Whether to include data previews for every table in the image.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.pull">
<code className="sig-name descname">pull</code><span className="sig-paren">(</span><em className="sig-param">download_all: Optional[bool] = False</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.repository.Repository.pull" title="Permalink to this definition">¶</a></dt>
<dd><p>Synchronizes the state of the local Splitgraph repository with its upstream, optionally downloading all new
objects created on the remote.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>download_all</strong> – If True, downloads all objects and stores them locally. Otherwise, will only download
required objects when a table is checked out.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.push">
<code className="sig-name descname">push</code><span className="sig-paren">(</span><em className="sig-param">remote_repository: Optional[Repository] = None</em>, <em className="sig-param">handler: str = 'DB'</em>, <em className="sig-param">handler_options: Optional[Dict[str</em>, <em className="sig-param">Any]] = None</em><span className="sig-paren">)</span> → splitgraph.core.repository.Repository<a className="headerlink" href="#splitgraph.core.repository.Repository.push" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse of <code className="docutils literal notranslate"><span className="pre">pull</span></code>: Pushes all local changes to the remote and uploads new objects.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>remote_repository</strong> – Remote repository to push changes to. If not specified, the current
upstream is used.</p></li>
<li><p><strong>handler</strong> – Name of the handler to use to upload objects. Use <cite>DB</cite> to push them to the remote or <cite>S3</cite>
to store them in an S3 bucket.</p></li>
<li><p><strong>handler_options</strong> – Extra options to pass to the handler. For example, see
<a className="reference internal" href="splitgraph.hooks/#splitgraph.hooks.s3.S3ExternalObjectHandler" title="splitgraph.hooks.s3.S3ExternalObjectHandler"><code className="xref py py-class docutils literal notranslate"><span className="pre">splitgraph.hooks.s3.S3ExternalObjectHandler</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.rollback_engines">
<code className="sig-name descname">rollback_engines</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.repository.Repository.rollback_engines" title="Permalink to this definition">¶</a></dt>
<dd><p>Rollback the underlying transactions on both engines that the repository uses.</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.run_sql">
<code className="sig-name descname">run_sql</code><span className="sig-paren">(</span><em className="sig-param">sql: Union[psycopg2.sql.Composed, str], arguments: Optional[Any] = None, return_shape: splitgraph.engine.ResultShape = &lt;ResultShape.MANY_MANY: 4></em><span className="sig-paren">)</span> → Any<a className="headerlink" href="#splitgraph.core.repository.Repository.run_sql" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute an arbitrary SQL statement inside of this repository’s checked out schema.</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.set_tags">
<code className="sig-name descname">set_tags</code><span className="sig-paren">(</span><em className="sig-param">tags: Dict[str, Optional[str]]</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.repository.Repository.set_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets tags for multiple images.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>tags</strong> – List of (image_hash, tag)</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.to_schema">
<code className="sig-name descname">to_schema</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → str<a className="headerlink" href="#splitgraph.core.repository.Repository.to_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the engine schema that this repository gets checked out into.</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.uncheckout">
<code className="sig-name descname">uncheckout</code><span className="sig-paren">(</span><em className="sig-param">force: bool = False</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.repository.Repository.uncheckout" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes the schema that the repository is checked out into</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>force</strong> – Discards all pending changes to the schema.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.repository.Repository.upstream">
<em className="property">property </em><code className="sig-name descname">upstream</code><a className="headerlink" href="#splitgraph.core.repository.Repository.upstream" title="Permalink to this definition">¶</a></dt>
<dd><p>The remote upstream repository that this local repository tracks.</p>
</dd></dl>

</dd></dl>

<dl className="function">
<dt id="splitgraph.core.repository.clone">
<code className="sig-prename descclassname">splitgraph.core.repository.</code><code className="sig-name descname">clone</code><span className="sig-paren">(</span><em className="sig-param">remote_repository: Union[Repository, str], local_repository: Optional[Repository] = None, download_all: Optional[bool] = False</em><span className="sig-paren">)</span> → splitgraph.core.repository.Repository<a className="headerlink" href="#splitgraph.core.repository.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Clones a remote Splitgraph repository or synchronizes remote changes with the local ones.</p>
<p>If the target repository has no set upstream engine, the source repository becomes its upstream.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>remote_repository</strong> – Remote Repository object to clone or the repository’s name. If a name is passed,
the repository will be looked up on the current lookup path in order to find the engine the repository
belongs to.</p></li>
<li><p><strong>local_repository</strong> – Local repository to clone into. If None, uses the same name as the remote.</p></li>
<li><p><strong>download_all</strong> – If True, downloads all objects and stores them locally. Otherwise, will only download required
objects when a table is checked out.</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>A locally cloned Repository object.</p>
</dd>
</dl>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.repository.getrandbits">
<code className="sig-prename descclassname">splitgraph.core.repository.</code><code className="sig-name descname">getrandbits</code><span className="sig-paren">(</span><em className="sig-param">k</em><span className="sig-paren">)</span> → x.  Generates an int with k random bits.<a className="headerlink" href="#splitgraph.core.repository.getrandbits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl className="function">
<dt id="splitgraph.core.repository.import_table_from_remote">
<code className="sig-prename descclassname">splitgraph.core.repository.</code><code className="sig-name descname">import_table_from_remote</code><span className="sig-paren">(</span><em className="sig-param">remote_repository: splitgraph.core.repository.Repository, remote_tables: List[str], remote_image_hash: str, target_repository: splitgraph.core.repository.Repository, target_tables: List[Any], target_hash: str = None</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.repository.import_table_from_remote" title="Permalink to this definition">¶</a></dt>
<dd><p>Shorthand for importing one or more tables from a yet-uncloned remote. Here, the remote image hash is required,
as otherwise we aren’t necessarily able to determine what the remote head is.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>remote_repository</strong> – Remote Repository object</p></li>
<li><p><strong>remote_tables</strong> – List of remote tables to import</p></li>
<li><p><strong>remote_image_hash</strong> – Image hash to import the tables from</p></li>
<li><p><strong>target_repository</strong> – Target repository to import the tables to</p></li>
<li><p><strong>target_tables</strong> – Target table aliases</p></li>
<li><p><strong>target_hash</strong> – Hash of the image that’s created with the import. Default random.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.repository.table_exists_at">
<code className="sig-prename descclassname">splitgraph.core.repository.</code><code className="sig-name descname">table_exists_at</code><span className="sig-paren">(</span><em className="sig-param">repository: splitgraph.core.repository.Repository</em>, <em className="sig-param">table_name: str</em>, <em className="sig-param">image: Optional[splitgraph.core.image.Image] = None</em><span className="sig-paren">)</span> → bool<a className="headerlink" href="#splitgraph.core.repository.table_exists_at" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines whether a given table exists in a Splitgraph image without checking it out. If <cite>image_hash</cite> is None,
determines whether the table exists in the current staging area.</p>
</dd></dl>

</div>
<div className="section" id="module-splitgraph.core.sql">
<span id="splitgraph-core-sql-module"></span><h2 id="splitgraphcoresql-module">splitgraph.core.sql module<a className="headerlink" href="#module-splitgraph.core.sql" title="Permalink to this headline">¶</a></h2>
<p>Routines for managing SQL statements</p>
<dl className="function">
<dt id="splitgraph.core.sql.validate_import_sql">
<code className="sig-prename descclassname">splitgraph.core.sql.</code><code className="sig-name descname">validate_import_sql</code><span className="sig-paren">(</span><em className="sig-param">sql: str</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.sql.validate_import_sql" title="Permalink to this definition">¶</a></dt>
<dd><p>Check an SQL query to see if it can be safely used in an IMPORT statement
(e.g. <cite>FROM noaa/climate:latest IMPORT &#38;lbrace;SELECT * FROM rainfall WHERE state = ‘AZ’&#38;rbrace; AS rainfall</cite>.
In this case, only a single SELECT statement is supported.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>sql</strong> – SQL query</p>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>None if validation is successful</p>
</dd>
<dt className="field-odd">Raises</dt>
<dd className="field-odd"><p>UnsupportedSQLException if validation failed</p>
</dd>
</dl>
</dd></dl>

<dl className="function">
<dt id="splitgraph.core.sql.validate_splitfile_sql">
<code className="sig-prename descclassname">splitgraph.core.sql.</code><code className="sig-name descname">validate_splitfile_sql</code><span className="sig-paren">(</span><em className="sig-param">sql: str</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.sql.validate_splitfile_sql" title="Permalink to this definition">¶</a></dt>
<dd><p>Check an SQL query to see if it can be safely used in a Splitfile SQL command. The rules for usage are:</p>
<blockquote>
<div><ul className="simple">
<li><p>Only basic DDL (CREATE/ALTER/DROP table) and DML (SELECT/INSERT/UPDATE/DELETE) are permitted.</p></li>
<li><p>All tables must be non-schema-qualified (the statement is run with <cite>search_path</cite> set to the single
schema that a Splitgraph image is checked out into).</p></li>
<li><p>Function invocations are forbidden.</p></li>
</ul>
</div></blockquote>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><p><strong>sql</strong> – SQL query</p>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>None if validation is successful</p>
</dd>
<dt className="field-odd">Raises</dt>
<dd className="field-odd"><p>UnsupportedSQLException if validation failed</p>
</dd>
</dl>
</dd></dl>

</div>
<div className="section" id="module-splitgraph.core.table">
<span id="splitgraph-core-table-module"></span><h2 id="splitgraphcoretable-module">splitgraph.core.table module<a className="headerlink" href="#module-splitgraph.core.table" title="Permalink to this headline">¶</a></h2>
<p>Table metadata-related classes.</p>
<dl className="class">
<dt id="splitgraph.core.table.QueryPlan">
<em className="property">class </em><code className="sig-prename descclassname">splitgraph.core.table.</code><code className="sig-name descname">QueryPlan</code><span className="sig-paren">(</span><em className="sig-param">table: splitgraph.core.table.Table, quals: Optional[Sequence[Sequence[Tuple[str, str, Any]]]], columns: Sequence[str]</em><span className="sig-paren">)</span><a className="headerlink" href="#splitgraph.core.table.QueryPlan" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code className="xref py py-class docutils literal notranslate"><span className="pre">object</span></code></p>
<p>Represents the initial query plan (fragments to query) for given columns and
qualifiers.</p>
</dd></dl>

<dl className="class">
<dt id="splitgraph.core.table.Table">
<em className="property">class </em><code className="sig-prename descclassname">splitgraph.core.table.</code><code className="sig-name descname">Table</code><span className="sig-paren">(</span><em className="sig-param">repository: Repository, image: Image, table_name: str, table_schema: List[splitgraph.core.types.TableColumn], objects: List[str]</em><span className="sig-paren">)</span><a className="headerlink" href="#splitgraph.core.table.Table" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code className="xref py py-class docutils literal notranslate"><span className="pre">object</span></code></p>
<p>Represents a Splitgraph table in a given image. Shouldn’t be created directly, use Table-loading
methods in the <a className="reference internal" href="#splitgraph.core.image.Image" title="splitgraph.core.image.Image"><code className="xref py py-class docutils literal notranslate"><span className="pre">splitgraph.core.image.Image</span></code></a> class instead.</p>
<dl className="method">
<dt id="splitgraph.core.table.Table.get_query_plan">
<code className="sig-name descname">get_query_plan</code><span className="sig-paren">(</span><em className="sig-param">quals: Optional[Sequence[Sequence[Tuple[str, str, Any]]]], columns: Sequence[str], use_cache: bool = True</em><span className="sig-paren">)</span> → splitgraph.core.table.QueryPlan<a className="headerlink" href="#splitgraph.core.table.Table.get_query_plan" title="Permalink to this definition">¶</a></dt>
<dd><p>Start planning a query (preliminary steps before object downloading,
like qualifier filtering).</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>quals</strong> – Qualifiers in CNF form</p></li>
<li><p><strong>columns</strong> – List of columns</p></li>
<li><p><strong>use_cache</strong> – If True, will fetch the plan from the cache for the same qualifiers and columns.</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>QueryPlan</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.table.Table.get_size">
<code className="sig-name descname">get_size</code><span className="sig-paren">(</span><span className="sig-paren">)</span> → int<a className="headerlink" href="#splitgraph.core.table.Table.get_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the physical size used by the image’s objects (including those shared with other tables).</p>
<p>This is calculated from the metadata, the on-disk footprint might be smaller if not all of table’s
objects have been downloaded.</p>
<dl className="field-list simple">
<dt className="field-odd">Returns</dt>
<dd className="field-odd"><p>Size of the table in bytes.</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.table.Table.materialize">
<code className="sig-name descname">materialize</code><span className="sig-paren">(</span><em className="sig-param">destination: str</em>, <em className="sig-param">destination_schema: Optional[str] = None</em>, <em className="sig-param">lq_server: Optional[str] = None</em><span className="sig-paren">)</span> → None<a className="headerlink" href="#splitgraph.core.table.Table.materialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Materializes a Splitgraph table in the target schema as a normal Postgres table, potentially downloading all
required objects and using them to reconstruct the table.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>destination</strong> – Name of the destination table.</p></li>
<li><p><strong>destination_schema</strong> – Name of the destination schema.</p></li>
<li><p><strong>lq_server</strong> – If set, sets up a layered querying FDW for the table instead using this foreign server.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.table.Table.query">
<code className="sig-name descname">query</code><span className="sig-paren">(</span><em className="sig-param">columns: List[str], quals: Sequence[Sequence[Tuple[str, str, Any]]]</em><span className="sig-paren">)</span><a className="headerlink" href="#splitgraph.core.table.Table.query" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a read-only query against this table without materializing it.</p>
<p>This is a wrapper around query_lazy() that force evaluates the results which
might mean more fragments being materialized that aren’t needed.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>columns</strong> – List of columns from this table to fetch</p></li>
<li><p><strong>quals</strong> – List of qualifiers in conjunctive normal form. See the documentation for
FragmentManager.filter_fragments for the actual format.</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>List of dictionaries of results</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.table.Table.query_indirect">
<code className="sig-name descname">query_indirect</code><span className="sig-paren">(</span><em className="sig-param">columns: List[str], quals: Optional[Sequence[Sequence[Tuple[str, str, Any]]]]</em><span className="sig-paren">)</span> → Tuple[Iterator[bytes], Callable, splitgraph.core.table.QueryPlan]<a className="headerlink" href="#splitgraph.core.table.Table.query_indirect" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a read-only query against this table without materializing it. Instead of
actual results, this returns a generator of SQL queries that the caller can use
to get the results as well as a callback that the caller has to run after they’re
done consuming the results.</p>
<p>In particular, the query generator will prefer returning direct queries to
Splitgraph objects and only when those are exhausted will it start materializing
delta-compressed fragments.</p>
<p>This is an advanced method: you probably want to call table.query().</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>columns</strong> – List of columns from this table to fetch</p></li>
<li><p><strong>quals</strong> – List of qualifiers in conjunctive normal form. See the documentation for
FragmentManager.filter_fragments for the actual format.</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>Generator of queries (bytes), a callback and a query plan object (containing stats
that are fully populated after the callback has been called to end the query).</p>
</dd>
</dl>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.table.Table.query_lazy">
<code className="sig-name descname">query_lazy</code><span className="sig-paren">(</span><em className="sig-param">columns: List[str], quals: Sequence[Sequence[Tuple[str, str, Any]]]</em><span className="sig-paren">)</span> → Iterator[Iterator[Dict[str, Any]]]<a className="headerlink" href="#splitgraph.core.table.Table.query_lazy" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a read-only query against this table without materializing it.</p>
<dl className="field-list simple">
<dt className="field-odd">Parameters</dt>
<dd className="field-odd"><ul className="simple">
<li><p><strong>columns</strong> – List of columns from this table to fetch</p></li>
<li><p><strong>quals</strong> – List of qualifiers in conjunctive normal form. See the documentation for
FragmentManager.filter_fragments for the actual format.</p></li>
</ul>
</dd>
<dt className="field-even">Returns</dt>
<dd className="field-even"><p>Generator of dictionaries of results.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div className="section" id="module-splitgraph.core.types">
<span id="splitgraph-core-types-module"></span><h2 id="splitgraphcoretypes-module">splitgraph.core.types module<a className="headerlink" href="#module-splitgraph.core.types" title="Permalink to this headline">¶</a></h2>
<dl className="class">
<dt id="splitgraph.core.types.TableColumn">
<em className="property">class </em><code className="sig-prename descclassname">splitgraph.core.types.</code><code className="sig-name descname">TableColumn</code><span className="sig-paren">(</span><em className="sig-param">ordinal</em>, <em className="sig-param">name</em>, <em className="sig-param">pg_type</em>, <em className="sig-param">is_pk</em>, <em className="sig-param">comment</em><span className="sig-paren">)</span><a className="headerlink" href="#splitgraph.core.types.TableColumn" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code className="xref py py-class docutils literal notranslate"><span className="pre">tuple</span></code></p>
<dl className="method">
<dt id="splitgraph.core.types.TableColumn.comment">
<em className="property">property </em><code className="sig-name descname">comment</code><a className="headerlink" href="#splitgraph.core.types.TableColumn.comment" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 4</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.types.TableColumn.is_pk">
<em className="property">property </em><code className="sig-name descname">is_pk</code><a className="headerlink" href="#splitgraph.core.types.TableColumn.is_pk" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 3</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.types.TableColumn.name">
<em className="property">property </em><code className="sig-name descname">name</code><a className="headerlink" href="#splitgraph.core.types.TableColumn.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.types.TableColumn.ordinal">
<em className="property">property </em><code className="sig-name descname">ordinal</code><a className="headerlink" href="#splitgraph.core.types.TableColumn.ordinal" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl className="method">
<dt id="splitgraph.core.types.TableColumn.pg_type">
<em className="property">property </em><code className="sig-name descname">pg_type</code><a className="headerlink" href="#splitgraph.core.types.TableColumn.pg_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

</dd></dl>

</div>

</div>
</div>