export const meta = {
  id: "advanced_splitfiles",
  title: "Advanced Splitfile usage"
};

There's one other advantage to using Splitfiles instead of building
images manually: provenance tracking. An image that is created by a
Splitfile has the specifics of the actual command that created it stored
in its metadata.

This means that we can output a list of images and repositories that
were used in an image's creation:

<code>console.log("hello world")</code>

```dockerfile
# syntax = docker/dockerfile:experimental
FROM postgres:11.5

RUN rm -f /etc/apt/apt.conf.d/docker-clean; \
    echo 'Binary::apt::APT::Keep-Downloaded-Packages "true";' \
    > /etc/apt/apt.conf.d/keep-cache

RUN --mount=type=cache,target=/var/cache/apt --mount=type=cache,target=/var/lib/apt apt-get update -qq \
    && apt-get install -yy \
    sudo \
    wget \
    build-essential \
    postgresql-server-dev-11 \
    luajit \
    libluajit-5.1-dev \
    curl \
    git \
    zlib1g-dev \
    libbz2-dev \
    libssl-dev \
    luarocks \
    lua-luaossl \
    libssl-dev \
    libkrb5-dev

# TODO: Some of these setup scripts download files and could also be used
# with a cache mount, maybe
RUN mkdir -p /splitgraph/setup
WORKDIR /splitgraph/setup

ADD setup/install_pllua.sh /splitgraph/setup/install_pllua.sh
RUN /splitgraph/setup/install_pllua.sh

ADD setup/install_python.sh /splitgraph/setup/install_python.sh
RUN /splitgraph/setup/install_python.sh

ADD setup/install_plpython.sh /splitgraph/setup/install_plpython.sh
RUN /splitgraph/setup/install_plpython.sh

ADD setup/setup_lua_installation.sh /splitgraph/setup/setup_lua_installation.sh
RUN /splitgraph/setup/setup_lua_installation.sh

ADD setup/install_python_base_deps.sh /splitgraph/setup/install_python_base_deps.sh
RUN /splitgraph/setup/install_python_base_deps.sh

# pgexts must come from a custom build context
ADD pgexts /home/postgres/pgexts
ADD setup/install_sgr_crypto.sh /splitgraph/setup/install_sgr_crypto.sh
RUN /splitgraph/setup/install_sgr_crypto.sh

VOLUME /var/lib/postgresql/data/pgdata
VOLUME /etc/postgresql

VOLUME /home/postgres/luamods
VOLUME /home/postgres/pymods

# Any image inheriting from this can ADD scripts to this folder, and they
# will be executed in lexiographic order by the entrypoint
RUN mkdir -p /splitgraph/entrypoint-scripts

RUN mkdir -p /var/lib/postgresql/data/pgdata/ \
    && chown -R postgres:postgres /var/lib/postgresql/data/pgdata/ \
    && chmod 0700 /var/lib/postgresql/data/pgdata/ \
    && chown -R postgres:postgres /usr/share/postgresql/11/extension/ \
    && chown -R postgres:postgres /home/postgres/ \
    && chown -R postgres:postgres /splitgraph/entrypoint-scripts

# Add postgres to sudo group to allow sudo in the entrypoint
# (TODO: This is dangerous. It's here because the entrypoint needs sudo to
# set permissions, which is kind of a hack and should ideally be unnecessary.)
RUN usermod -aG sudo postgres \
    && ( echo "postgres ALL=(ALL) NOPASSWD:ALL" | tee -a /etc/sudoers ; )

ADD pgbase_entrypoint.sh /home/postgres/pgbase_entrypoint.sh

USER postgres

EXPOSE 5432

ENTRYPOINT ["/home/postgres/pgbase_entrypoint.sh"]

CMD ["postgres", "-D", "/etc/postgresql", "-c", "data_directory=/var/lib/postgresql/data/pgdata"]
```

```javascript
console.log("hello world");

function() {
    for (let i = 0; i < 10; i++) {
        console.log("Hello", i)
    }
}

# 10 Characters:
# aaaaaaaa

# 20 Characters:
# aaaaaaaabbbbbbbbbb

# 20 Characters:
# aaaaaaaabbbbbbbbbb

# 30 Characters:
# aaaaaaaabbbbbbbbbbbbbbbbbbbb

# 45 Characters:
# aaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

# 50 Characters:
# aaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

# 55 Characters
# aaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

# 60 Characters
# aaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

# 65 Characters
# aaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

# 70 Characters
# aaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

# 80 Characters
# aaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

# 90 Characters
# aaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

```

```
$ sgr provenance example/output:latest

example/output:4fd86d48715d2a3e250810fbdaa43d21ed0a894cd00de9bc118d9191e6294741 depends on:
example/repo_2:97900a8279627ec22b355d1211dd824f78f5840b6a0e30e1d285f4e5c6120016
example/repo_1:103cb2da2da000f3dce9512e3cc67434d7a3c977c0df259411c73a2687244706
```

Since the Splitfile in the previous section imported tables from the two
generated repositories, these repositories are considered to be
`example/output`'s dependencies (note that the `example/output`
repository can still be checked out and used without those two
repositories present).

We can also run the dependency query backwards, querying which images were built from
a certain image:

```
$ sgr dependents example/repo_1:latest

example/repo_1:103cb2da2da000f3dce9512e3cc67434d7a3c977c0df259411c73a2687244706 is depended on by:
example/output:4fd86d48715d2a3e250810fbdaa43d21ed0a894cd00de9bc118d9191e6294741
```

However, that's not all. We can reconstruct a Splitfile that can be
used to rebuild the newly created image, without the original Splitfile
present:

    $ sgr provenance example/output:latest --full

    # Splitfile commands used to recreate example/output:4fd86d48715d2a3e250810fbdaa43d21ed0a894cd00de9bc118d9191e6294741
    FROM example/repo_1:103cb2da2da000f3dce9512e3cc67434d7a3c977c0df259411c73a2687244706 IMPORT demo AS table_1
    FROM example/repo_2:97900a8279627ec22b355d1211dd824f78f5840b6a0e30e1d285f4e5c6120016 IMPORT demo AS table_2
    SQL {CREATE TABLE result
      AS SELECT table_1.key
              , table_1.value AS value_1
              , table_2.value AS value_2
         FROM table_1
              INNER JOIN table_2 ON table_1.key = table_2.key}

Unlike Dockerfiles and building application images, in this case
everything that is needed to rebuild a certain image (links to source
images and the actual commands) is encoded in the provenance
information. In particular, this means that we can rebuild the
`example/output:latest` image against a different version of any of its
dependencies by simply substituting a different image hash into this
regenerated Splitfile:

    $ sgr rebuild example/output:latest --against example/repo_2:new_data
    Rerunning example/output:4fd86d48715d2a3e250810fbdaa43d21ed0a894cd00de9bc118d9191e6294741 against:
    example/repo_2:new_data

    Step 1/3 : FROM example/repo_1:103cb2da2da000f3dce9512e3cc67434d7a3c...
    Resolving repository example/repo_1
     ---> Using cache
     ---> 27aeabd37f2c

    Step 2/3 : FROM example/repo_2:new_data IMPORT demo AS table_2
    Resolving repository example/repo_2
    Importing 1 table from example/repo_2:48407a3cef8a into example/output
     ---> ca85929a90e7

    Step 3/3 : SQL {CREATE TABLE result  AS SELECT table_1.key        ...
    Executing SQL...
    Committing example/output...
    Processing table result
    Computing table partitions
    Indexing the partition key
    Storing and indexing the table
    100%|█████████████████| 1/1 [00:00<00:00,  6.33objs/s]
     ---> 46b6a361bebd

Since the same image from `example/repo_1` is used here, the first step
in the execution results in the same image hash and so the image is
simply checked out. However, since the image from `example/repo_2` is
now the altered one that we created in the previous section, the rest of
the derivation has to be rerun.

Let's examine the new result:

    $ sgr sql --schema example/output "SELECT * FROM result ORDER BY key"
    2       d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35        d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35_UPDATED
    3       4e07408562bedb8b60ce05c1decfe3ad16b72230967de01f640b7e4729b49fce        4e07408562bedb8b60ce05c1decfe3ad16b72230967de01f640b7e4729b49fce_UPDATED
    4       4b227777d4dd1fc61c6f884f48641d02b4d121d3fd328cb08b5531fcacdabf8a        4b227777d4dd1fc61c6f884f48641d02b4d121d3fd328cb08b5531fcacdabf8a
    5       ef2d127de37b942baad06145e54b0c619a1f22327b2ebbcfbec78f5564afe39d        ef2d127de37b942baad06145e54b0c619a1f22327b2ebbcfbec78f5564afe39d
    6       e7f6c011776e8db7cd330b54174fd76f7d0216b612387a5ffcfb81e6f0919683        e7f6c011776e8db7cd330b54174fd76f7d0216b612387a5ffcfb81e6f0919683
    7       7902699be42c8a8e46fbbb4501726517e86b22c56a189f7625a6da49081b2451        7902699be42c8a8e46fbbb4501726517e86b22c56a189f7625a6da49081b2451
    8       2c624232cdd221771294dfbb310aca000a0df6ac8b66b696d90ef06fdefb64a3        2c624232cdd221771294dfbb310aca000a0df6ac8b66b696d90ef06fdefb64a3
    9       19581e27de7ced00ff1ce50b2047e7a567c76b1cbaebabe5ef03f7c3017bb5b7        19581e27de7ced00ff1ce50b2047e7a567c76b1cbaebabe5ef03f7c3017bb5b7

Since the first two rows are now missing from `example/repo_2`, the JOIN
result doesn't have them either.

The Splitfile executor still caches images in this case, so if we do a `rebuild` against
the original version of `example/repo_1`, the first version of
`example/output` will be checked out:

    $ sgr rebuild example/output:latest --against example/repo_2:original_data
    Rerunning example/output:46b6a361bebd3c16ea23030f91645f683487690b8c695f4585c1b01238ec1d1d against:
    example/repo_2:original_data

    Step 1/3 : FROM example/repo_1:103cb2da2da000f3dce9512e3cc67434d7a3c...
    Resolving repository example/repo_1
     ---> Using cache
     ---> 27aeabd37f2c

    Step 2/3 : FROM example/repo_2:original_data IMPORT demo AS table_2
    Resolving repository example/repo_2
     ---> Using cache
     ---> ee4dbe8a8167

    Step 3/3 : SQL {CREATE TABLE result  AS SELECT table_1.key        ...
     ---> Using cache
     ---> 4fd86d48715d
