export const meta = {
  id: "advanced_splitfiles",
  title: "Advanced Splitfile usage"
};

There's one other advantage to using Splitfiles instead of building
images manually: provenance tracking. An image that is created by a
Splitfile has the specifics of the actual command that created it stored
in its metadata.

This means that we can output a list of images and repositories that
were used in an image's creation:

<code>console.log("hello world")</code>

```dockerfile
# syntax = docker/dockerfile:experimental
FROM postgres:11.5

RUN rm -f /etc/apt/apt.conf.d/docker-clean; \
    echo 'Binary::apt::APT::Keep-Downloaded-Packages "true";' \
    > /etc/apt/apt.conf.d/keep-cache

RUN --mount=type=cache,target=/var/cache/apt --mount=type=cache,target=/var/lib/apt apt-get update -qq \
    && apt-get install -yy \
    sudo \
    wget \
    build-essential \
    postgresql-server-dev-11 \
    luajit \
    libluajit-5.1-dev \
    curl \
    git \
    zlib1g-dev \
    libbz2-dev \
    libssl-dev \
    luarocks \
    lua-luaossl \
    libssl-dev \
    libkrb5-dev

# TODO: Some of these setup scripts download files and could also be used
# with a cache mount, maybe
RUN mkdir -p /splitgraph/setup
WORKDIR /splitgraph/setup

ADD setup/install_pllua.sh /splitgraph/setup/install_pllua.sh
RUN /splitgraph/setup/install_pllua.sh

ADD setup/install_python.sh /splitgraph/setup/install_python.sh
RUN /splitgraph/setup/install_python.sh

ADD setup/install_plpython.sh /splitgraph/setup/install_plpython.sh
RUN /splitgraph/setup/install_plpython.sh

ADD setup/setup_lua_installation.sh /splitgraph/setup/setup_lua_installation.sh
RUN /splitgraph/setup/setup_lua_installation.sh

ADD setup/install_python_base_deps.sh /splitgraph/setup/install_python_base_deps.sh
RUN /splitgraph/setup/install_python_base_deps.sh

# pgexts must come from a custom build context
ADD pgexts /home/postgres/pgexts
ADD setup/install_sgr_crypto.sh /splitgraph/setup/install_sgr_crypto.sh
RUN /splitgraph/setup/install_sgr_crypto.sh

VOLUME /var/lib/postgresql/data/pgdata
VOLUME /etc/postgresql

VOLUME /home/postgres/luamods
VOLUME /home/postgres/pymods

# Any image inheriting from this can ADD scripts to this folder, and they
# will be executed in lexiographic order by the entrypoint
RUN mkdir -p /splitgraph/entrypoint-scripts

RUN mkdir -p /var/lib/postgresql/data/pgdata/ \
    && chown -R postgres:postgres /var/lib/postgresql/data/pgdata/ \
    && chmod 0700 /var/lib/postgresql/data/pgdata/ \
    && chown -R postgres:postgres /usr/share/postgresql/11/extension/ \
    && chown -R postgres:postgres /home/postgres/ \
    && chown -R postgres:postgres /splitgraph/entrypoint-scripts

# Add postgres to sudo group to allow sudo in the entrypoint
# (TODO: This is dangerous. It's here because the entrypoint needs sudo to
# set permissions, which is kind of a hack and should ideally be unnecessary.)
RUN usermod -aG sudo postgres \
    && ( echo "postgres ALL=(ALL) NOPASSWD:ALL" | tee -a /etc/sudoers ; )

ADD pgbase_entrypoint.sh /home/postgres/pgbase_entrypoint.sh

USER postgres

EXPOSE 5432

ENTRYPOINT ["/home/postgres/pgbase_entrypoint.sh"]

CMD ["postgres", "-D", "/etc/postgresql", "-c", "data_directory=/var/lib/postgresql/data/pgdata"]
```

```javascript
console.log("hello world");

function() {
    for (let i = 0; i < 10; i++) {
        console.log("Hello", i)
    }
}

# 10 Characters:
# aaaaaaaa

# 20 Characters:
# aaaaaaaabbbbbbbbbb

# 20 Characters:
# aaaaaaaabbbbbbbbbb

# 30 Characters:
# aaaaaaaabbbbbbbbbbbbbbbbbbbb

# 45 Characters:
# aaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

# 50 Characters:
# aaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

# 55 Characters
# aaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

# 60 Characters
# aaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

# 65 Characters
# aaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

# 70 Characters
# aaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

# 80 Characters
# aaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

# 90 Characters
# aaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

```

```
$ sgr provenance example/output:latest

example/output:96833d33a4333d33fd2490ca2ec8ebab83be5481cb17372b9a66e1518253a111 depends on:
example/repo_2:6881def87f34aa1d7501d2960719fd6b5df9c392053278eade089b3186ee8407
example/repo_1:5fe74f282e33fb78dda67b3c96f9f915e949d06a643d0b50ce5f74f35ad1e3c7
```

Since the Splitfile in the previous section imported tables from the two
generated repositories, these repositories are considered to be
`example/output`'s dependencies (note that the `example/output`
repository can still be checked out and used without those two
repositories present).

However, that's not all. We can also reconstruct a Splitfile that can be
used to rebuild the newly created image, without the original Splitfile
present:

    $ sgr provenance example/output:latest --full

    # Splitfile commands used to recreate example/output:96833d33a4333d33fd2490ca2ec8ebab83be5481cb17372b9a66e1518253a111
    FROM example/repo_1:5fe74f282e33fb78dda67b3c96f9f915e949d06a643d0b50ce5f74f35ad1e3c7 IMPORT demo AS table_1
    FROM example/repo_2:6881def87f34aa1d7501d2960719fd6b5df9c392053278eade089b3186ee8407 IMPORT demo AS table_2
    SQL CREATE TABLE result AS SELECT table_1.key, table_1.value AS value_1, table_2.value AS value_2 FROM table_1 JOIN table_2 ON table_1.key = table_2.key

Unlike Dockerfiles and building filesystem images, in this case
everything that is needed to rebuild a certain image (links to source
images and the actual commands) is encoded in the provenance
information. In particular, this means that we can rebuild the
`example/output:latest` image against a different version of any of its
dependencies by simply substituting a different image hash into this
regenerated Splitfile:

    $ sgr rebuild example/output:latest --against example/repo_2:new_data

    Rerunning example/output:96833d33a4333d33fd2490ca2ec8ebab83be5481cb17372b9a66e1518253a111 against:
    example/repo_2:new_data

    Step 1/3 : FROM example/repo_1:5fe74f282e33fb78dda67b3c96f9f915e949d...
    Resolving repository example/repo_1
     ---> Using cache
     ---> 73c258b9a244

    Step 2/3 : FROM example/repo_2:new_data IMPORT demo AS table_2
    Resolving repository example/repo_2
    Importing tables ('demo',):a0057ef93849 from example/repo_2 into example/output
    2019-01-01 15:07:49,632 INFO Applying obd90d0188367a0d9c1b06dff92a729a97d360d50c9fc94438b1b70d71842a5...
     ---> bc8791660f6d

    Step 3/3 : SQL CREATE TABLE result AS SELECT table_1.key, table_1.va...
    Executing SQL...
    2019-01-01 15:07:49,695 INFO Committing example/output...
     ---> a2c37225c2d1

Since the same image from `example/repo_1` is used here, the first step
in the execution results in the same image hash and so the image is
simply checked out. However, since the image from `example/repo_2` is
now the altered one that we created in the previous section, the rest of
the derivation has to be rerun.

Let's examine the new result:

    $ sgr sql --schema example/output "SELECT * FROM result ORDER BY key"

    [(2,
      'd4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35',
      'd4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35_UPDATED'),
     (3,
      '4e07408562bedb8b60ce05c1decfe3ad16b72230967de01f640b7e4729b49fce',
      '4e07408562bedb8b60ce05c1decfe3ad16b72230967de01f640b7e4729b49fce_UPDATED'),
     (4,
      '4b227777d4dd1fc61c6f884f48641d02b4d121d3fd328cb08b5531fcacdabf8a',
      '4b227777d4dd1fc61c6f884f48641d02b4d121d3fd328cb08b5531fcacdabf8a'),
     (5,
      'ef2d127de37b942baad06145e54b0c619a1f22327b2ebbcfbec78f5564afe39d',
      'ef2d127de37b942baad06145e54b0c619a1f22327b2ebbcfbec78f5564afe39d'),
     (6,
      'e7f6c011776e8db7cd330b54174fd76f7d0216b612387a5ffcfb81e6f0919683',
      'e7f6c011776e8db7cd330b54174fd76f7d0216b612387a5ffcfb81e6f0919683'),
     (7,
      '7902699be42c8a8e46fbbb4501726517e86b22c56a189f7625a6da49081b2451',
      '7902699be42c8a8e46fbbb4501726517e86b22c56a189f7625a6da49081b2451'),
     (8,
      '2c624232cdd221771294dfbb310aca000a0df6ac8b66b696d90ef06fdefb64a3',
      '2c624232cdd221771294dfbb310aca000a0df6ac8b66b696d90ef06fdefb64a3'),
     (9,
      '19581e27de7ced00ff1ce50b2047e7a567c76b1cbaebabe5ef03f7c3017bb5b7',
      '19581e27de7ced00ff1ce50b2047e7a567c76b1cbaebabe5ef03f7c3017bb5b7')]

Since the first two rows are now missing from `example/repo_2`, the JOIN
result doesn't have them either.

The caching behaviour still holds here, so if we do a `rebuild` against
the original version of `example/repo_1`, the first version of
`example/output` will be checked out:

    $ sgr rebuild example/output:latest --against example/repo_2:original_data

    Rerunning example/output:a2c37225c2d162c0d78bc15195a740e3a231bb9c1b5f37c00d3bf04560c63216 against:
    example/repo_2:original_data

    Step 1/3 : FROM example/repo_1:5fe74f282e33fb78dda67b3c96f9f915e949d...
    Resolving repository example/repo_1
     ---> Using cache
     ---> 73c258b9a244

    Step 2/3 : FROM example/repo_2:original_data IMPORT demo AS table_2
    Resolving repository example/repo_2
     ---> Using cache
     ---> 9764d69bbc46

    Step 3/3 : SQL CREATE TABLE result AS SELECT table_1.key, table_1.va...
     ---> Using cache
     ---> 96833d33a433
